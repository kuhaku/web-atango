// Generated by CoffeeScript 1.8.0
var BoneMotion, CameraMotion, LightMotion, ModelMotion, MorphMotion, PMDBone, PMDIK, PMDJoint, PMDMaterial, PMDMorph, PMDRigidBody, PMDVertex, PMXBone, PMXFrame, PMXJoint, PMXMaterial, PMXMorph, PMXRigidBody, PMXVertex, SelfShadowMotion, bezierp, checkSize, fraction, ipfunc, ipfuncd, lerp1, loadImage, previousRegisteredFrame, size_Float32, size_Int8, size_Uint16, size_Uint32, size_Uint8, slice,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

this.MMD = (function() {
  function MMD(canvas, width, height) {
    this.width = width;
    this.height = height;
    this.gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
    if (!this.gl) {
      alert('WebGL not supported in your browser');
      throw 'WebGL not supported';
    }
    this.model_count = 0;
    this.models = {};
    this.renderers = {};
    this.initMatrices();
    this.initParameters();
  }

  MMD.prototype.initMatrices = function() {
    this.mvMatrixStack = [];
    this.pMatrix = mat4.createIdentity();
    return this.mvMatrix = mat4.createIdentity();
  };

  MMD.prototype.mvPushMatrix = function() {
    var copy;
    copy = mat4.create();
    mat4.set(this.mvMatrix, copy);
    return this.mvMatrixStack.push(copy);
  };

  MMD.prototype.mvPopMatrix = function() {
    if (this.mvMatrixStack.length === 0) {
      throw "Invalid popMatrix!";
    }
    return this.mvMatrix = this.mvMatrixStack.pop();
  };

  MMD.prototype.initShaders = function(vShaderSource, fShaderSource) {
    var attributes, fshader, line, name, program, src, type, uniforms, vshader, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2;
    vshader = this.gl.createShader(this.gl.VERTEX_SHADER);
    this.gl.shaderSource(vshader, vShaderSource);
    this.gl.compileShader(vshader);
    if (!this.gl.getShaderParameter(vshader, this.gl.COMPILE_STATUS)) {
      alert('Vertex shader compilation error');
      throw this.gl.getShaderInfoLog(vshader);
    }
    fshader = this.gl.createShader(this.gl.FRAGMENT_SHADER);
    this.gl.shaderSource(fshader, fShaderSource);
    this.gl.compileShader(fshader);
    if (!this.gl.getShaderParameter(fshader, this.gl.COMPILE_STATUS)) {
      alert('Fragment shader compilation error');
      throw this.gl.getShaderInfoLog(fshader);
    }
    program = this.gl.createProgram();
    this.gl.attachShader(program, vshader);
    this.gl.attachShader(program, fshader);
    this.gl.linkProgram(program);
    if (!this.gl.getProgramParameter(program, this.gl.LINK_STATUS)) {
      alert('Shader linking error');
      throw this.gl.getProgramInfoLog(program);
    }
    this.gl.useProgram(program);
    attributes = [];
    uniforms = [];
    _ref = [vShaderSource, fShaderSource];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      src = _ref[_i];
      _ref1 = src.replace(/\/\*[\s\S]*?\*\//g, '').replace(/\/\/[^\n]*/g, '').split(';');
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        line = _ref1[_j];
        type = (_ref2 = line.match(/^\s*(uniform|attribute)\s+/)) != null ? _ref2[1] : void 0;
        if (!type) {
          continue;
        }
        name = line.match(/(\w+)(\[\d+\])?\s*$/)[1];
        if (type === 'attribute' && __indexOf.call(attributes, name) < 0) {
          attributes.push(name);
        }
        if (type === 'uniform' && __indexOf.call(uniforms, name) < 0) {
          uniforms.push(name);
        }
      }
    }
    console.log("===============");
    for (_k = 0, _len2 = attributes.length; _k < _len2; _k++) {
      name = attributes[_k];
      program[name] = this.gl.getAttribLocation(program, name);
      this.gl.enableVertexAttribArray(program[name]);
      console.log("" + name + ": " + program[name] + " => " + (this.gl.getError()));
    }
    for (_l = 0, _len3 = uniforms.length; _l < _len3; _l++) {
      name = uniforms[_l];
      program[name] = this.gl.getUniformLocation(program, name);
    }
    return program;
  };

  MMD.prototype.addModel = function(name, model) {
    this.models[name] = model;
    this.model_count++;
  };

  MMD.prototype.getModelRenderer = function(name) {
    return this.renderers[name];
  };

  MMD.prototype.load = function(callback) {
    var model, name, that, _ref;
    that = this;
    _ref = this.models;
    for (name in _ref) {
      model = _ref[name];
      model.load(function() {
        var k, m, _ref1;
        if (--that.model_count <= 0) {
          _ref1 = that.models;
          for (k in _ref1) {
            m = _ref1[k];
            that.renderers[k] = new MMD.Renderer(that, m);
          }
          return callback();
        }
      });
    }
  };

  MMD.prototype.start = function() {
    var before, count, interval, step, t0;
    this.gl.clearColor(1, 1, 1, 1);
    this.gl.clearDepth(1);
    this.gl.enable(this.gl.DEPTH_TEST);
    this.redraw = true;
    if (this.drawSelfShadow) {
      this.shadowMap = new MMD.ShadowMap(this);
    }
    this.motionManager = new MMD.MotionManager;
    count = 0;
    t0 = before = Date.now();
    interval = 1000 / this.fps;
    step = (function(_this) {
      return function() {
        var now;
        _this.move();
        _this.render();
        now = Date.now();
        if (++count % _this.fps === 0) {
          _this.realFps = _this.fps / (now - before) * 1000;
          before = now;
        }
        return setTimeout(step, (t0 + count * interval) - now);
      };
    })(this);
    step();
  };

  MMD.prototype.move = function() {
    var key, renderer, _ref;
    _ref = this.renderers;
    for (key in _ref) {
      renderer = _ref[key];
      if (renderer.playing) {
        renderer.move();
      }
    }
  };

  MMD.prototype.computeMatrices = function(modelMatrix) {
    var up;
    this.cameraPosition = vec3.create([0, 0, this.distance]);
    vec3.rotateX(this.cameraPosition, this.rotx);
    vec3.rotateY(this.cameraPosition, this.roty);
    vec3.moveBy(this.cameraPosition, this.center);
    up = [0, 1, 0];
    vec3.rotateX(up, this.rotx);
    vec3.rotateY(up, this.roty);
    this.viewMatrix = mat4.lookAt(this.cameraPosition, this.center, up);
    this.mvMatrix = mat4.createMultiply(this.viewMatrix, modelMatrix);
    this.pMatrix = mat4.perspective(this.fovy, this.width / this.height, 0.1, 1000.0);
    this.nMatrix = mat4.inverseTranspose(this.mvMatrix, mat4.create());
  };

  MMD.prototype.render = function() {
    var key, renderer, _ref;
    if (!this.redraw && !this.playing) {
      return;
    }
    this.redraw = false;
    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);
    this.gl.viewport(0, 0, this.width, this.height);
    this.gl.clearColor(0.0, 0.0, 0.0, 1.0);
    this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
    _ref = this.renderers;
    for (key in _ref) {
      renderer = _ref[key];
      this.mvPushMatrix();
      this.computeMatrices(renderer.modelMatrix);
      renderer.render();
      this.mvPopMatrix();
    }
    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);
    this.gl.viewport(0, 0, this.width, this.height);
    this.gl.flush();
  };

  MMD.prototype.setPMDUniforms = function() {
    var lightDirection;
    if (this.pmdProgram == null) {
      this.pmdProgram = this.initShaders(MMD.PMDVertexShaderSource, MMD.PMDFragmentShaderSource);
    }
    this.gl.useProgram(this.pmdProgram);
    this.gl.uniform1f(this.pmdProgram.uEdgeThickness, this.edgeThickness);
    this.gl.uniform3fv(this.pmdProgram.uEdgeColor, this.edgeColor);
    this.gl.uniformMatrix4fv(this.pmdProgram.uMVMatrix, false, this.mvMatrix);
    this.gl.uniformMatrix4fv(this.pmdProgram.uPMatrix, false, this.pMatrix);
    this.gl.uniformMatrix4fv(this.pmdProgram.uNMatrix, false, this.nMatrix);
    lightDirection = vec3.createNormalize(this.lightDirection);
    mat4.multiplyVec3(this.nMatrix, lightDirection);
    this.gl.uniform3fv(this.pmdProgram.uLightDirection, lightDirection);
    this.gl.uniform3fv(this.pmdProgram.uLightColor, this.lightColor);
  };

  MMD.prototype.setPMXUniforms = function() {
    var lightDirection;
    if (this.pmxProgram == null) {
      this.pmxProgram = this.initShaders(MMD.PMXVertexShaderSource, MMD.PMXFragmentShaderSource);
    }
    this.gl.useProgram(this.pmxProgram);
    this.gl.uniformMatrix4fv(this.pmxProgram.uMVMatrix, false, this.mvMatrix);
    this.gl.uniformMatrix4fv(this.pmxProgram.uPMatrix, false, this.pMatrix);
    this.gl.uniformMatrix4fv(this.pmxProgram.uNMatrix, false, this.nMatrix);
    lightDirection = vec3.createNormalize(this.lightDirection);
    mat4.multiplyVec3(this.nMatrix, lightDirection);
    this.gl.uniform3fv(this.pmxProgram.uLightDirection, lightDirection);
    this.gl.uniform3fv(this.pmxProgram.uLightColor, this.lightColor);
  };

  MMD.prototype.registerKeyListener = function(element) {
    element.addEventListener('keydown', (function(_this) {
      return function(e) {
        switch (e.keyCode + e.shiftKey * 1000 + e.ctrlKey * 10000 + e.altKey * 100000) {
          case 37:
            _this.roty += Math.PI / 48;
            break;
          case 39:
            _this.roty -= Math.PI / 48;
            break;
          case 38:
            _this.rotx += Math.PI / 48;
            break;
          case 40:
            _this.rotx -= Math.PI / 48;
            break;
          case 33:
            _this.distance -= 3 * _this.distance / _this.DIST;
            break;
          case 34:
            _this.distance += 3 * _this.distance / _this.DIST;
            break;
          case 36:
            _this.rotx = _this.roty = 0;
            _this.center = [0, 10, 0];
            _this.distance = _this.DIST;
            break;
          case 1037:
            vec3.multiplyMat4(_this.center, _this.mvMatrix);
            _this.center[0] -= _this.distance / _this.DIST;
            vec3.multiplyMat4(_this.center, mat4.createInverse(_this.mvMatrix));
            break;
          case 1039:
            vec3.multiplyMat4(_this.center, _this.mvMatrix);
            _this.center[0] += _this.distance / _this.DIST;
            vec3.multiplyMat4(_this.center, mat4.createInverse(_this.mvMatrix));
            break;
          case 1038:
            vec3.multiplyMat4(_this.center, _this.mvMatrix);
            _this.center[1] += _this.distance / _this.DIST;
            vec3.multiplyMat4(_this.center, mat4.createInverse(_this.mvMatrix));
            break;
          case 1040:
            vec3.multiplyMat4(_this.center, _this.mvMatrix);
            _this.center[1] -= _this.distance / _this.DIST;
            vec3.multiplyMat4(_this.center, mat4.createInverse(_this.mvMatrix));
            break;
          case 32:
            if (_this.playing) {
              _this.pause();
            } else {
              _this.play();
            }
            break;
          default:
            return;
        }
        e.preventDefault();
        return _this.redraw = true;
      };
    })(this), false);
  };

  MMD.prototype.registerMouseListener = function(element) {
    this.registerDragListener(element);
    this.registerWheelListener(element);
  };

  MMD.prototype.registerDragListener = function(element) {
    element.addEventListener('mousedown', (function(_this) {
      return function(e) {
        var modifier, move, onmousemove, onmouseup, ox, oy;
        if (e.button !== 0) {
          return;
        }
        modifier = e.shiftKey * 1000 + e.ctrlKey * 10000 + e.altKey * 100000;
        if (modifier !== 0 && modifier !== 1000) {
          return;
        }
        ox = e.clientX;
        oy = e.clientY;
        move = function(dx, dy, modi) {
          if (modi === 0) {
            _this.roty -= dx / 100;
            _this.rotx -= dy / 100;
            return _this.redraw = true;
          } else if (modi === 1000) {
            vec3.multiplyMat4(_this.center, _this.mvMatrix);
            _this.center[0] -= dx / 30 * _this.distance / _this.DIST;
            _this.center[1] += dy / 30 * _this.distance / _this.DIST;
            vec3.multiplyMat4(_this.center, mat4.createInverse(_this.mvMatrix));
            return _this.redraw = true;
          }
        };
        onmouseup = function(e) {
          var modi;
          if (e.button !== 0) {
            return;
          }
          modi = e.shiftKey * 1000 + e.ctrlKey * 10000 + e.altKey * 100000;
          move(e.clientX - ox, e.clientY - oy, modi);
          element.removeEventListener('mouseup', onmouseup, false);
          element.removeEventListener('mousemove', onmousemove, false);
          return e.preventDefault();
        };
        onmousemove = function(e) {
          var modi, x, y;
          if (e.button !== 0) {
            return;
          }
          modi = e.shiftKey * 1000 + e.ctrlKey * 10000 + e.altKey * 100000;
          x = e.clientX;
          y = e.clientY;
          move(x - ox, y - oy, modi);
          ox = x;
          oy = y;
          return e.preventDefault();
        };
        element.addEventListener('mouseup', onmouseup, false);
        return element.addEventListener('mousemove', onmousemove, false);
      };
    })(this), false);
  };

  MMD.prototype.registerWheelListener = function(element) {
    var onwheel;
    onwheel = (function(_this) {
      return function(e) {
        var delta;
        delta = e.detail || e.wheelDelta / (-40);
        _this.distance += delta * _this.distance / _this.DIST;
        _this.redraw = true;
        return e.preventDefault();
      };
    })(this);
    if ('onmousewheel' in window) {
      element.addEventListener('mousewheel', onwheel, false);
    } else {
      element.addEventListener('DOMMouseScroll', onwheel, false);
    }
  };

  MMD.prototype.initParameters = function() {
    this.ignoreCameraMotion = false;
    this.rotx = this.roty = 0;
    this.distance = this.DIST = 35;
    this.center = [0, 10, 0];
    this.fovy = 40;
    this.drawEdge = true;
    this.edgeThickness = 0.004;
    this.edgeColor = [0, 0, 0];
    this.lightDirection = [0.5, 1.0, 0.5];
    this.lightDistance = 8875;
    this.lightColor = [0.6, 0.6, 0.6];
    this.drawSelfShadow = true;
    this.drawAxes = true;
    this.drawCenterPoint = false;
    this.fps = 30;
    this.realFps = this.fps;
    this.playing = false;
    this.frame = -1;
  };

  MMD.prototype.play = function() {
    this.playing = true;
  };

  MMD.prototype.pause = function() {
    this.playing = false;
  };

  MMD.prototype.rewind = function() {
    this.setFrameNumber(-1);
  };

  MMD.prototype.setFrameNumber = function(num) {
    this.frame = num;
  };

  return MMD;

})();

this.MMD.Model = function(directory, filename) {
  var tmp;
  tmp = filename.toLowerCase();
  if ((tmp.indexOf("pmd")) !== -1) {
    return new MMD.PMDModel(directory, filename);
  }
  if ((tmp.indexOf("pmx")) !== -1) {
    return new MMD.PMXModel(directory, filename);
  }
  throw "Unknown model format!";
};

this.MMD.Renderer = function(mmd, model) {
  switch (model.type) {
    case "PMD":
      return new MMD.PMDRenderer(mmd, model);
    case "PMX":
      return new MMD.PMXRenderer(mmd, model);
    default:
      throw "No matching renderer for format " + model.type + "!";
  }
};

size_Uint8 = Uint8Array.BYTES_PER_ELEMENT;

size_Uint32 = Uint32Array.BYTES_PER_ELEMENT;

size_Float32 = Float32Array.BYTES_PER_ELEMENT;

slice = Array.prototype.slice;

this.MMD.Motion = (function() {
  function Motion(path) {
    this.path = path;
  }

  Motion.prototype.load = function(callback) {
    var xhr;
    xhr = new XMLHttpRequest;
    xhr.open('GET', this.path, true);
    xhr.responseType = 'arraybuffer';
    xhr.onload = (function(_this) {
      return function() {
        console.time('parse');
        _this.parse(xhr.response);
        console.timeEnd('parse');
        return callback();
      };
    })(this);
    return xhr.send();
  };

  Motion.prototype.parse = function(buffer) {
    var length, offset, view;
    length = buffer.byteLength;
    view = new DataView(buffer, 0);
    offset = 0;
    offset = this.checkHeader(buffer, view, offset);
    offset = this.getModelName(buffer, view, offset);
    offset = this.getBoneMotion(buffer, view, offset);
    offset = this.getMorphMotion(buffer, view, offset);
    offset = this.getCameraMotion(buffer, view, offset);
    offset = this.getLightMotion(buffer, view, offset);
    return offset = this.getSelfShadowMotion(buffer, view, offset);
  };

  Motion.prototype.checkHeader = function(buffer, view, offset) {
    if ('Vocaloid Motion Data 0002\0\0\0\0\0' !== String.fromCharCode.apply(null, slice.call(new Uint8Array(buffer, offset, 30)))) {
      throw 'File is not VMD';
    }
    return offset += 30 * size_Uint8;
  };

  Motion.prototype.getModelName = function(buffer, view, offset) {
    this.model_name = sjisArrayToString(new Uint8Array(buffer, offset, 20));
    return offset += size_Uint8 * 20;
  };

  Motion.prototype.getBoneMotion = function(buffer, view, offset) {
    var i, length;
    length = view.getUint32(offset, true);
    offset += size_Uint32;
    this.bone = (function() {
      var _i, _results;
      _results = [];
      for (i = _i = 0; 0 <= length ? _i < length : _i > length; i = 0 <= length ? ++_i : --_i) {
        _results.push(new BoneMotion(buffer, view, offset + i * BoneMotion.size));
      }
      return _results;
    })();
    return offset += length * BoneMotion.size;
  };

  Motion.prototype.getMorphMotion = function(buffer, view, offset) {
    var i, length;
    length = view.getUint32(offset, true);
    offset += size_Uint32;
    this.morph = (function() {
      var _i, _results;
      _results = [];
      for (i = _i = 0; 0 <= length ? _i < length : _i > length; i = 0 <= length ? ++_i : --_i) {
        _results.push(new MorphMotion(buffer, view, offset + i * MorphMotion.size));
      }
      return _results;
    })();
    return offset += length * MorphMotion.size;
  };

  Motion.prototype.getCameraMotion = function(buffer, view, offset) {
    var i, length;
    length = view.getUint32(offset, true);
    offset += size_Uint32;
    this.camera = (function() {
      var _i, _results;
      _results = [];
      for (i = _i = 0; 0 <= length ? _i < length : _i > length; i = 0 <= length ? ++_i : --_i) {
        _results.push(new CameraMotion(buffer, view, offset + i * CameraMotion.size));
      }
      return _results;
    })();
    return offset += length * CameraMotion.size;
  };

  Motion.prototype.getLightMotion = function(buffer, view, offset) {
    var i, length;
    length = view.getUint32(offset, true);
    offset += size_Uint32;
    this.light = (function() {
      var _i, _results;
      _results = [];
      for (i = _i = 0; 0 <= length ? _i < length : _i > length; i = 0 <= length ? ++_i : --_i) {
        _results.push(new LightMotion(buffer, view, offset + i * LightMotion.size));
      }
      return _results;
    })();
    return offset += length * LightMotion.size;
  };

  Motion.prototype.getSelfShadowMotion = function(buffer, view, offset) {
    var i, length;
    length = view.getUint32(offset, true);
    offset += size_Uint32;
    this.selfshadow = (function() {
      var _i, _results;
      _results = [];
      for (i = _i = 0; 0 <= length ? _i < length : _i > length; i = 0 <= length ? ++_i : --_i) {
        _results.push(new SelfShadowMotion(buffer, view, offset + i * SelfShadowMotion.size));
      }
      return _results;
    })();
    return offset += length * SelfShadowMotion.size;
  };

  return Motion;

})();

BoneMotion = (function() {
  function BoneMotion(buffer, view, offset) {
    var i, tmp, _i;
    this.name = sjisArrayToString(new Uint8Array(buffer, offset, 15));
    offset += size_Uint8 * 15;
    this.frame = view.getUint32(offset, true);
    offset += size_Uint32;
    tmp = [];
    tmp[0] = view.getFloat32(offset, true);
    offset += size_Float32;
    tmp[1] = view.getFloat32(offset, true);
    offset += size_Float32;
    tmp[2] = -view.getFloat32(offset, true);
    offset += size_Float32;
    this.location = new Float32Array(tmp);
    tmp[0] = -view.getFloat32(offset, true);
    offset += size_Float32;
    tmp[1] = -view.getFloat32(offset, true);
    offset += size_Float32;
    tmp[2] = view.getFloat32(offset, true);
    offset += size_Float32;
    tmp[3] = view.getFloat32(offset, true);
    offset += size_Float32;
    this.rotation = new Float32Array(tmp);
    for (i = _i = 0; _i < 64; i = ++_i) {
      tmp[i] = view.getUint8(offset, true);
      offset += size_Uint8;
    }
    this.interpolation = new Uint8Array(tmp);
  }

  return BoneMotion;

})();

BoneMotion.size = size_Uint8 * (15 + 64) + size_Uint32 + size_Float32 * 7;

MorphMotion = (function() {
  function MorphMotion(buffer, view, offset) {
    this.name = sjisArrayToString(new Uint8Array(buffer, offset, 15));
    offset += size_Uint8 * 15;
    this.frame = view.getUint32(offset, true);
    offset += size_Uint32;
    this.weight = view.getFloat32(offset, true);
    offset += size_Float32;
  }

  return MorphMotion;

})();

MorphMotion.size = size_Uint8 * 15 + size_Uint32 + size_Float32;

CameraMotion = (function() {
  function CameraMotion(buffer, view, offset) {
    var i, tmp, _i;
    this.frame = view.getUint32(offset, true);
    offset += size_Uint32;
    this.distance = -view.getFloat32(offset, true);
    offset += size_Float32;
    tmp = [];
    tmp[0] = view.getFloat32(offset, true);
    offset += size_Float32;
    tmp[1] = view.getFloat32(offset, true);
    offset += size_Float32;
    tmp[2] = -view.getFloat32(offset, true);
    offset += size_Float32;
    this.location = new Float32Array(tmp);
    tmp[0] = -view.getFloat32(offset, true);
    offset += size_Float32;
    tmp[1] = -view.getFloat32(offset, true);
    offset += size_Float32;
    tmp[2] = view.getFloat32(offset, true);
    offset += size_Float32;
    this.rotation = new Float32Array(tmp);
    for (i = _i = 0; _i < 24; i = ++_i) {
      tmp[i] = view.getUint8(offset, true);
      offset += size_Uint8;
    }
    this.interpolation = new Uint8Array(tmp);
    this.view_angle = view.getUint32(offset, true);
    offset += size_Uint32;
    this.noPerspective = view.getUint8(offset, true);
    offset += size_Uint8;
  }

  return CameraMotion;

})();

CameraMotion.size = size_Float32 * 7 + size_Uint8 * 25 + size_Float32 * 2;

LightMotion = (function() {
  function LightMotion(buffer, view, offset) {
    var tmp;
    this.frame = view.getUint32(offset, true);
    offset += size_Uint32;
    tmp = [];
    tmp[0] = view.getFloat32(offset, true);
    offset += size_Float32;
    tmp[1] = view.getFloat32(offset, true);
    offset += size_Float32;
    tmp[2] = view.getFloat32(offset, true);
    offset += size_Float32;
    this.color = new Float32Array(tmp);
    tmp = [];
    tmp[0] = -view.getFloat32(offset, true);
    offset += size_Float32;
    tmp[1] = -view.getFloat32(offset, true);
    offset += size_Float32;
    tmp[2] = view.getFloat32(offset, true);
    offset += size_Float32;
    this.location = new Float32Array(tmp);
  }

  return LightMotion;

})();

LightMotion.size = size_Float32 * 6 + size_Uint32;

SelfShadowMotion = (function() {
  function SelfShadowMotion(buffer, view, offset) {
    this.frame = view.getUint32(offset, true);
    offset += size_Uint32;
    this.mode = view.getUint8(offset, true);
    offset += size_Uint8;
    this.distance = view.getFloat32(offset, true);
    offset += size_Float32;
  }

  return SelfShadowMotion;

})();

SelfShadowMotion.size = size_Float32 + size_Uint8 + size_Float32;

MMD.MotionManager = (function() {
  function MotionManager() {
    this.modelMotions = [];
    this.cameraMotion = [];
    this.cameraFrames = [];
    this.lightMotion = [];
    this.lightFrames = [];
    this.lastFrame = 0;
    return;
  }

  MotionManager.prototype.addModelMotion = function(model, motion, merge_flag, frame_offset) {
    var i, mm, _i, _len, _ref;
    _ref = this.modelMotions;
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      mm = _ref[i];
      if (model === mm.model) {
        break;
      }
    }
    if (i === this.modelMotions.length) {
      mm = new ModelMotion(model);
      this.modelMotions.push(mm);
    }
    mm.addBoneMotion(motion.bone, merge_flag, frame_offset);
    mm.addMorphMotion(motion.morph, merge_flag, frame_offset);
    this.lastFrame = mm.lastFrame;
  };

  MotionManager.prototype.getModelFrame = function(model, frame) {
    var i, mm, _i, _len, _ref;
    _ref = this.modelMotions;
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      mm = _ref[i];
      if (model === mm.model) {
        break;
      }
    }
    if (i === this.modelMotions.length) {
      return {};
    }
    return {
      bones: mm.getBoneFrame(frame),
      morphs: mm.getMorphFrame(frame)
    };
  };

  MotionManager.prototype.addCameraLightMotion = function(motion, merge_flag, frame_offset) {
    this.addCameraMotoin(motion.camera, merge_flag, frame_offset);
    this.addLightMotoin(motion.light, merge_flag, frame_offset);
  };

  MotionManager.prototype.addCameraMotion = function(camera, merge_flag, frame_offset) {
    var c, frame, _i, _len;
    if (camera.length === 0) {
      return;
    }
    if (!merge_flag) {
      this.cameraMotion = [];
      this.cameraFrames = [];
    }
    frame_offset = frame_offset || 0;
    for (_i = 0, _len = camera.length; _i < _len; _i++) {
      c = camera[_i];
      frame = c.frame + frame_offset;
      this.cameraMotion[frame] = c;
      this.cameraFrames.push(frame);
      if (this.lastFrame < frame) {
        this.lastFrame = frame;
      }
    }
    this.cameraFrames = this.cameraFrames.sort(function(a, b) {
      return a - b;
    });
  };

  MotionManager.prototype.addLightMotoin = function(light, merge_flag, frame_offset) {
    var frame, l, _i, _len;
    if (light.length === 0) {
      return;
    }
    if (!merge_flag) {
      this.lightMotion = [];
      this.lightFrames = [];
    }
    frame_offset = frame_offset || 0;
    for (_i = 0, _len = light.length; _i < _len; _i++) {
      l = light[_i];
      frame = l.frame + frame_offset;
      this.lightMotion[frame] = l;
      this.lightFrames.push(frame);
      if (this.lastFrame < frame) {
        this.lastFrame = frame;
      }
    }
    this.lightFrames = this.lightFrames.sort(function(a, b) {
      return a - b;
    });
  };

  MotionManager.prototype.getCameraFrame = function(frame) {
    var bez, cache, camera, frac, frames, idx, lastFrame, n, next, p, prev, timeline;
    if (!this.cameraMotion.length) {
      return null;
    }
    timeline = this.cameraMotion;
    frames = this.cameraFrames;
    lastFrame = frames[frames.length - 1];
    if (lastFrame <= frame) {
      camera = timeline[lastFrame];
    } else {
      idx = previousRegisteredFrame(frames, frame);
      p = frames[idx];
      n = frames[idx + 1];
      frac = fraction(frame, p, n);
      prev = timeline[p];
      next = timeline[n];
      cache = [];
      bez = function(i) {
        var X1, X2, Y1, Y2, id;
        X1 = next.interpolation[i * 4];
        X2 = next.interpolation[i * 4 + 1];
        Y1 = next.interpolation[i * 4 + 2];
        Y2 = next.interpolation[i * 4 + 3];
        id = X1 | (X2 << 8) | (Y1 << 16) | (Y2 << 24);
        if (cache[id] != null) {
          return cache[id];
        }
        if (X1 === Y1 && X2 === Y2) {
          return cache[id] = frac;
        }
        return cache[id] = bezierp(X1 / 127, X2 / 127, Y1 / 127, Y2 / 127, frac);
      };
      camera = {
        location: vec3.createLerp3(prev.location, next.location, [bez(0), bez(1), bez(2)]),
        rotation: vec3.createLerp(prev.rotation, next.rotation, bez(3)),
        distance: lerp1(prev.distance, next.distance, bez(4)),
        view_angle: lerp1(prev.view_angle, next.view_angle, bez(5))
      };
    }
    return camera;
  };

  MotionManager.prototype.getLightFrame = function(frame) {
    var frac, frames, idx, lastFrame, light, n, next, p, prev, timeline;
    if (!this.lightMotion.length) {
      return null;
    }
    timeline = this.lightMotion;
    frames = this.lightFrames;
    lastFrame = frames[frames.length - 1];
    if (lastFrame <= frame) {
      light = timeline[lastFrame];
    } else {
      idx = previousRegisteredFrame(frames, frame);
      p = frames[idx];
      n = frames[idx + 1];
      frac = fraction(frame, p, n);
      prev = timeline[p];
      next = timeline[n];
      light = {
        color: vec3.createLerp(prev.color, next.color, frac),
        location: vec3.lerp(prev.location, next.location, frac)
      };
    }
    return light;
  };

  return MotionManager;

})();

ModelMotion = (function() {
  function ModelMotion(model) {
    this.model = model;
    this.boneMotions = {};
    this.boneFrames = {};
    this.morphMotions = {};
    this.morphFrames = {};
    this.lastFrame = 0;
  }

  ModelMotion.prototype.addBoneMotion = function(bone, merge_flag, frame_offset) {
    var b, frame, name, _i, _len;
    if (!merge_flag) {
      this.boneMotions = {};
      this.boneFrames = {};
    }
    frame_offset = frame_offset || 0;
    for (_i = 0, _len = bone.length; _i < _len; _i++) {
      b = bone[_i];
      if (!this.boneMotions[b.name]) {
        this.boneMotions[b.name] = [
          {
            location: vec3.create(),
            rotation: quat4.create([0, 0, 0, 1])
          }
        ];
      }
      frame = b.frame + frame_offset;
      this.boneMotions[b.name][frame] = b;
      if (this.lastFrame < frame) {
        this.lastFrame = frame;
      }
    }
    for (name in this.boneMotions) {
      this.boneFrames[name] = (this.boneFrames[name] || []).concat(Object.keys(this.boneMotions[name]).map(Number)).sort(function(a, b) {
        return a - b;
      });
    }
  };

  ModelMotion.prototype.addMorphMotion = function(morph, merge_flag, frame_offset) {
    var frame, m, name, _i, _len;
    if (!merge_flag) {
      this.morphMotions = {};
      this.morphFrames = {};
    }
    frame_offset = frame_offset || 0;
    for (_i = 0, _len = morph.length; _i < _len; _i++) {
      m = morph[_i];
      if (m.name === 'base') {
        continue;
      }
      if (!this.morphMotions[m.name]) {
        this.morphMotions[m.name] = [0];
      }
      frame = m.frame + frame_offset;
      this.morphMotions[m.name][frame] = m.weight;
      if (this.lastFrame < frame) {
        this.lastFrame = frame;
      }
    }
    for (name in this.morphMotions) {
      this.morphFrames[name] = (this.morphFrames[name] || []).concat(Object.keys(this.morphMotions[name]).map(Number)).sort(function(a, b) {
        return a - b;
      });
    }
  };

  ModelMotion.prototype.getBoneFrame = function(frame) {
    var bez, bones, cache, frac, frames, idx, lastFrame, n, name, next, p, prev, r, rotation, timeline;
    bones = {};
    for (name in this.boneMotions) {
      timeline = this.boneMotions[name];
      frames = this.boneFrames[name];
      lastFrame = frames[frames.length - 1];
      if (lastFrame <= frame) {
        bones[name] = timeline[lastFrame];
      } else {
        idx = previousRegisteredFrame(frames, frame);
        p = frames[idx];
        n = frames[idx + 1];
        frac = fraction(frame, p, n);
        prev = timeline[p];
        next = timeline[n];
        cache = [];
        bez = function(i) {
          var X1, X2, Y1, Y2, id;
          X1 = next.interpolation[i * 4];
          X2 = next.interpolation[i * 4 + 1];
          Y1 = next.interpolation[i * 4 + 2];
          Y2 = next.interpolation[i * 4 + 3];
          id = X1 | (X2 << 8) | (Y1 << 16) | (Y2 << 24);
          if (cache[id] != null) {
            return cache[id];
          }
          if (X1 === Y1 && X2 === Y2) {
            return cache[id] = frac;
          }
          return cache[id] = bezierp(X1 / 127, X2 / 127, Y1 / 127, Y2 / 127, frac);
        };
        if (quat4.dot(prev.rotation, next.rotation) >= 0) {
          rotation = quat4.createSlerp(prev.rotation, next.rotation, bez(3));
        } else {
          r = prev.rotation;
          rotation = quat4.createSlerp([-r[0], -r[1], -r[2], -r[3]], next.rotation, bez(3));
        }
        bones[name] = {
          location: vec3.createLerp3(prev.location, next.location, [bez(0), bez(1), bez(2)]),
          rotation: rotation
        };
      }
    }
    return bones;
  };

  ModelMotion.prototype.getMorphFrame = function(frame) {
    var frac, frames, idx, lastFrame, morphs, n, name, next, p, prev, timeline;
    morphs = {};
    for (name in this.morphMotions) {
      timeline = this.morphMotions[name];
      frames = this.morphFrames[name];
      lastFrame = frames[frames.length - 1];
      if (lastFrame <= frame) {
        morphs[name] = timeline[lastFrame];
      } else {
        idx = previousRegisteredFrame(frames, frame);
        p = frames[idx];
        n = frames[idx + 1];
        frac = fraction(frame, p, n);
        prev = timeline[p];
        next = timeline[n];
        morphs[name] = lerp1(prev, next, frac);
      }
    }
    return morphs;
  };

  return ModelMotion;

})();

previousRegisteredFrame = function(frames, frame) {

  /*
    'frames' is key frames registered, 'frame' is the key frame I'm enquiring about
    ex. frames: [0,10,20,30,40,50], frame: 15
    now I want to find the numbers 10 and 20, namely the ones before 15 and after 15
    I'm doing a bisection search here.
   */
  var delta, idx;
  idx = 0;
  delta = frames.length;
  while (true) {
    delta = (delta >> 1) || 1;
    if (frames[idx] <= frame) {
      if (delta === 1 && frames[idx + 1] > frame) {
        break;
      }
      idx += delta;
    } else {
      idx -= delta;
      if (delta === 1 && frames[idx] <= frame) {
        break;
      }
    }
  }
  return idx;
};

fraction = function(x, x0, x1) {
  return (x - x0) / (x1 - x0);
};

lerp1 = function(x0, x1, a) {
  return x0 + a * (x1 - x0);
};

bezierp = function(x1, x2, y1, y2, x) {

  /*
    interpolate using Bezier curve (http://musashi.or.tv/fontguide_doc3.htm)
    Bezier curve is parametrized by t (0 <= t <= 1)
      x = s^3 x_0 + 3 s^2 t x_1 + 3 s t^2 x_2 + t^3 x_3
      y = s^3 y_0 + 3 s^2 t y_1 + 3 s t^2 y_2 + t^3 y_3
    where s is defined as s = 1 - t.
    Especially, for MMD, (x_0, y_0) = (0, 0) and (x_3, y_3) = (1, 1), so
      x = 3 s^2 t x_1 + 3 s t^2 x_2 + t^3
      y = 3 s^2 t y_1 + 3 s t^2 y_2 + t^3
    Now, given x, find t by bisection method (http://en.wikipedia.org/wiki/Bisection_method)
    i.e. find t such that f(t) = 3 s^2 t x_1 + 3 s t^2 x_2 + t^3 - x = 0
    One thing to note here is that f(t) is monotonically increasing in the range [0,1]
    Therefore, when I calculate f(t) for the t I guessed,
    Finally find y for the t.
   */
  var t, tt, v;
  t = x;
  while (true) {
    v = ipfunc(t, x1, x2) - x;
    if (v * v < 0.0000001) {
      break;
    }
    tt = ipfuncd(t, x1, x2);
    if (tt === 0) {
      break;
    }
    t -= v / tt;
  }
  return ipfunc(t, y1, y2);
};

ipfunc = function(t, p1, p2) {
  return (1 + 3 * p1 - 3 * p2) * t * t * t + (3 * p2 - 6 * p1) * t * t + 3 * p1 * t;
};

ipfuncd = function(t, p1, p2) {
  return (3 + 9 * p1 - 9 * p2) * t * t + (6 * p2 - 12 * p1) * t + 3 * p1;
};

size_Int8 = Int8Array.BYTES_PER_ELEMENT;

size_Uint8 = Uint8Array.BYTES_PER_ELEMENT;

size_Uint16 = Uint16Array.BYTES_PER_ELEMENT;

size_Uint32 = Uint32Array.BYTES_PER_ELEMENT;

size_Float32 = Float32Array.BYTES_PER_ELEMENT;

slice = Array.prototype.slice;

this.MMD.PMDModel = (function() {
  function PMDModel(directory, filename) {
    this.type = "PMD";
    this.directory = directory;
    this.filename = filename;
    this.vertices = null;
    this.triangles = null;
    this.materials = null;
    this.bones = null;
    this.morphs = null;
    this.morph_order = null;
    this.bone_group_names = null;
    this.bone_table = null;
    this.english_flag = null;
    this.english_name = null;
    this.english_comment = null;
    this.english_bone_names = null;
    this.english_morph_names = null;
    this.english_bone_group_names = null;
    this.toon_file_names = null;
    this.rigid_bodies = null;
    this.joints = null;
  }

  PMDModel.prototype.load = function(callback) {
    var xhr;
    xhr = new XMLHttpRequest;
    xhr.open('GET', this.directory + '/' + this.filename, true);
    xhr.responseType = 'arraybuffer';
    xhr.onload = (function(_this) {
      return function() {
        console.time("parse " + _this.filename);
        _this.parse(xhr.response);
        console.timeEnd("parse " + _this.filename);
        return callback();
      };
    })(this);
    return xhr.send();
  };

  PMDModel.prototype.parse = function(buffer) {
    var length, offset, view;
    length = buffer.byteLength;
    view = new DataView(buffer, 0);
    offset = 0;
    offset = this.checkHeader(buffer, view, offset);
    offset = this.getName(buffer, view, offset);
    offset = this.getVertices(buffer, view, offset);
    offset = this.getTriangles(buffer, view, offset);
    offset = this.getMaterials(buffer, view, offset);
    offset = this.getBones(buffer, view, offset);
    offset = this.getIKs(buffer, view, offset);
    offset = this.getMorphs(buffer, view, offset);
    offset = this.getMorphOrder(buffer, view, offset);
    offset = this.getBoneGroupNames(buffer, view, offset);
    offset = this.getBoneTable(buffer, view, offset);
    if (offset >= length) {
      return;
    }
    offset = this.getEnglishFlag(buffer, view, offset);
    if (this.english_flag) {
      offset = this.getEnglishName(buffer, view, offset);
      offset = this.getEnglishBoneNames(buffer, view, offset);
      offset = this.getEnglishMorphNames(buffer, view, offset);
      offset = this.getEnglishBoneGroupNames(buffer, view, offset);
    }
    if (offset >= length) {
      return;
    }
    offset = this.getToonFileNames(buffer, view, offset);
    if (offset >= length) {
      return;
    }
    offset = this.getRigidBodies(buffer, view, offset);
    return offset = this.getJoints(buffer, view, offset);
  };

  PMDModel.prototype.checkHeader = function(buffer, view, offset) {
    if (view.getUint8(0) !== 'P'.charCodeAt(0) || view.getUint8(1) !== 'm'.charCodeAt(0) || view.getUint8(2) !== 'd'.charCodeAt(0) || view.getUint8(3) !== 0x00 || view.getUint8(4) !== 0x00 || view.getUint8(5) !== 0x80 || view.getUint8(6) !== 0x3F) {
      throw 'File is not PMD';
    }
    return offset += 7 * size_Uint8;
  };

  PMDModel.prototype.getName = function(buffer, view, offset) {
    var block;
    block = new Uint8Array(buffer, offset, 20 + 256);
    this.name = sjisArrayToString(slice.call(block, 0, 20));
    this.comment = sjisArrayToString(slice.call(block, 20, 20 + 256));
    return offset += (20 + 256) * size_Uint8;
  };

  PMDModel.prototype.getVertices = function(buffer, view, offset) {
    var i, length;
    length = view.getUint32(offset, true);
    offset += size_Uint32;
    this.vertices = (function() {
      var _i, _results;
      _results = [];
      for (i = _i = 0; 0 <= length ? _i < length : _i > length; i = 0 <= length ? ++_i : --_i) {
        _results.push(new PMDVertex(buffer, view, offset + i * PMDVertex.size));
      }
      return _results;
    })();
    return offset += length * PMDVertex.size;
  };

  PMDModel.prototype.getTriangles = function(buffer, view, offset) {
    var i, length, _i;
    length = view.getUint32(offset, true);
    offset += size_Uint32;
    this.triangles = new Uint16Array(length);
    for (i = _i = 0; _i < length; i = _i += 3) {
      this.triangles[i + 1] = view.getUint16(offset + i * size_Uint16, true);
      this.triangles[i] = view.getUint16(offset + (i + 1) * size_Uint16, true);
      this.triangles[i + 2] = view.getUint16(offset + (i + 2) * size_Uint16, true);
    }
    return offset += length * size_Uint16;
  };

  PMDModel.prototype.getMaterials = function(buffer, view, offset) {
    var i, length;
    length = view.getUint32(offset, true);
    offset += size_Uint32;
    this.materials = (function() {
      var _i, _results;
      _results = [];
      for (i = _i = 0; 0 <= length ? _i < length : _i > length; i = 0 <= length ? ++_i : --_i) {
        _results.push(new PMDMaterial(buffer, view, offset + i * PMDMaterial.size));
      }
      return _results;
    })();
    return offset += length * PMDMaterial.size;
  };

  PMDModel.prototype.getBones = function(buffer, view, offset) {
    var i, length;
    length = view.getUint16(offset, true);
    offset += size_Uint16;
    this.bones = (function() {
      var _i, _results;
      _results = [];
      for (i = _i = 0; 0 <= length ? _i < length : _i > length; i = 0 <= length ? ++_i : --_i) {
        _results.push(new PMDBone(buffer, view, offset + i * PMDBone.size));
      }
      return _results;
    })();
    return offset += length * PMDBone.size;
  };

  PMDModel.prototype.getIKs = function(buffer, view, offset) {
    var i, ik, length;
    length = view.getUint16(offset, true);
    offset += size_Uint16;
    this.iks = (function() {
      var _i, _results;
      _results = [];
      for (i = _i = 0; 0 <= length ? _i < length : _i > length; i = 0 <= length ? ++_i : --_i) {
        ik = new PMDIK(buffer, view, offset);
        offset += ik.getSize();
        _results.push(ik);
      }
      return _results;
    })();
    return offset;
  };

  PMDModel.prototype.getMorphs = function(buffer, view, offset) {
    var i, length, morph;
    length = view.getUint16(offset, true);
    offset += size_Uint16;
    this.morphs = (function() {
      var _i, _results;
      _results = [];
      for (i = _i = 0; 0 <= length ? _i < length : _i > length; i = 0 <= length ? ++_i : --_i) {
        morph = new PMDMorph(buffer, view, offset);
        offset += morph.getSize();
        _results.push(morph);
      }
      return _results;
    })();
    return offset;
  };

  PMDModel.prototype.getMorphOrder = function(buffer, view, offset) {
    var i, length;
    length = view.getUint8(offset);
    offset += size_Uint8;
    this.morph_order = (function() {
      var _i, _results;
      _results = [];
      for (i = _i = 0; 0 <= length ? _i < length : _i > length; i = 0 <= length ? ++_i : --_i) {
        _results.push(view.getUint16(offset + i * size_Uint16, true));
      }
      return _results;
    })();
    return offset += length * size_Uint16;
  };

  PMDModel.prototype.getBoneGroupNames = function(buffer, view, offset) {
    var block, i, length;
    length = view.getUint8(offset);
    offset += size_Uint8;
    block = new Uint8Array(buffer, offset, 50 * length);
    this.bone_group_names = (function() {
      var _i, _results;
      _results = [];
      for (i = _i = 0; 0 <= length ? _i < length : _i > length; i = 0 <= length ? ++_i : --_i) {
        _results.push(sjisArrayToString(slice.call(block, i * 50, (i + 1) * 50)));
      }
      return _results;
    })();
    return offset += length * 50 * size_Uint8;
  };

  PMDModel.prototype.getBoneTable = function(buffer, view, offset) {
    var bone, i, length;
    length = view.getUint32(offset, true);
    offset += size_Uint32;
    this.bone_table = (function() {
      var _i, _results;
      _results = [];
      for (i = _i = 0; 0 <= length ? _i < length : _i > length; i = 0 <= length ? ++_i : --_i) {
        bone = {};
        bone.index = view.getUint16(offset, true);
        offset += size_Uint16;
        bone.group_index = view.getUint8(offset);
        offset += size_Uint8;
        _results.push(bone);
      }
      return _results;
    })();
    return offset;
  };

  PMDModel.prototype.getEnglishFlag = function(buffer, view, offset) {
    this.english_flag = view.getUint8(offset);
    return offset += size_Uint8;
  };

  PMDModel.prototype.getEnglishName = function(buffer, view, offset) {
    var block;
    block = new Uint8Array(buffer, offset, 20 + 256);
    this.english_name = sjisArrayToString(slice.call(block, 0, 20));
    this.english_comment = sjisArrayToString(slice.call(block, 20, 20 + 256));
    return offset += (20 + 256) * size_Uint8;
  };

  PMDModel.prototype.getEnglishBoneNames = function(buffer, view, offset) {
    var block, i, length;
    length = this.bones.length;
    block = new Uint8Array(buffer, offset, 20 * length);
    this.english_bone_names = (function() {
      var _i, _results;
      _results = [];
      for (i = _i = 0; 0 <= length ? _i < length : _i > length; i = 0 <= length ? ++_i : --_i) {
        _results.push(sjisArrayToString(slice.call(block, i * 20, (i + 1) * 20)));
      }
      return _results;
    })();
    return offset += length * 20 * size_Uint8;
  };

  PMDModel.prototype.getEnglishMorphNames = function(buffer, view, offset) {
    var block, i, length;
    length = this.morphs.length - 1;
    if (length < 0) {
      length = 0;
    }
    block = new Uint8Array(buffer, offset, 20 * length);
    this.english_morph_names = (function() {
      var _i, _results;
      _results = [];
      for (i = _i = 0; 0 <= length ? _i < length : _i > length; i = 0 <= length ? ++_i : --_i) {
        _results.push(sjisArrayToString(slice.call(block, i * 20, (i + 1) * 20)));
      }
      return _results;
    })();
    return offset += length * 20 * size_Uint8;
  };

  PMDModel.prototype.getEnglishBoneGroupNames = function(buffer, view, offset) {
    var block, i, length;
    length = this.bone_group_names.length;
    block = new Uint8Array(buffer, offset, 50 * length);
    this.english_bone_group_names = (function() {
      var _i, _results;
      _results = [];
      for (i = _i = 0; 0 <= length ? _i < length : _i > length; i = 0 <= length ? ++_i : --_i) {
        _results.push(sjisArrayToString(slice.call(block, i * 50, (i + 1) * 50)));
      }
      return _results;
    })();
    return offset += length * 50 * size_Uint8;
  };

  PMDModel.prototype.getToonFileNames = function(buffer, view, offset) {
    var block, i;
    block = new Uint8Array(buffer, offset, 100 * 10);
    this.toon_file_names = (function() {
      var _i, _results;
      _results = [];
      for (i = _i = 0; _i < 10; i = ++_i) {
        _results.push(sjisArrayToString(slice.call(block, i * 100, (i + 1) * 100)));
      }
      return _results;
    })();
    return offset += 100 * 10 * size_Uint8;
  };

  PMDModel.prototype.getRigidBodies = function(buffer, view, offset) {
    var i, length;
    length = view.getUint32(offset, true);
    offset += size_Uint32;
    this.rigid_bodies = (function() {
      var _i, _results;
      _results = [];
      for (i = _i = 0; 0 <= length ? _i < length : _i > length; i = 0 <= length ? ++_i : --_i) {
        _results.push(new PMDRigidBody(buffer, view, offset + i * PMDRigidBody.size));
      }
      return _results;
    })();
    return offset += length * PMDRigidBody.size;
  };

  PMDModel.prototype.getJoints = function(buffer, view, offset) {
    var i, length;
    length = view.getUint32(offset, true);
    offset += size_Uint32;
    this.joints = (function() {
      var _i, _results;
      _results = [];
      for (i = _i = 0; 0 <= length ? _i < length : _i > length; i = 0 <= length ? ++_i : --_i) {
        _results.push(new PMDJoint(buffer, view, offset + i * PMDJoint.size));
      }
      return _results;
    })();
    return offset += length * PMDJoint.size;
  };

  return PMDModel;

})();

PMDVertex = (function() {
  function PMDVertex(buffer, view, offset) {
    this.x = view.getFloat32(offset, true);
    offset += size_Float32;
    this.y = view.getFloat32(offset, true);
    offset += size_Float32;
    this.z = -view.getFloat32(offset, true);
    offset += size_Float32;
    this.nx = view.getFloat32(offset, true);
    offset += size_Float32;
    this.ny = view.getFloat32(offset, true);
    offset += size_Float32;
    this.nz = -view.getFloat32(offset, true);
    offset += size_Float32;
    this.u = view.getFloat32(offset, true);
    offset += size_Float32;
    this.v = view.getFloat32(offset, true);
    offset += size_Float32;
    this.bone_num1 = view.getUint16(offset, true);
    offset += size_Uint16;
    this.bone_num2 = view.getUint16(offset, true);
    offset += size_Uint16;
    this.bone_weight = view.getUint8(offset);
    offset += size_Uint8;
    this.edge_flag = view.getUint8(offset);
    offset += size_Uint8;
  }

  return PMDVertex;

})();

PMDVertex.size = size_Float32 * 8 + size_Uint16 * 2 + size_Uint8 * 2;

PMDMaterial = (function() {
  function PMDMaterial(buffer, view, offset) {
    var i, tmp;
    tmp = [];
    tmp[0] = view.getFloat32(offset, true);
    offset += size_Float32;
    tmp[1] = view.getFloat32(offset, true);
    offset += size_Float32;
    tmp[2] = view.getFloat32(offset, true);
    offset += size_Float32;
    this.diffuse = new Float32Array(tmp);
    this.alpha = view.getFloat32(offset, true);
    offset += size_Float32;
    this.shininess = view.getFloat32(offset, true);
    offset += size_Float32;
    tmp[0] = view.getFloat32(offset, true);
    offset += size_Float32;
    tmp[1] = view.getFloat32(offset, true);
    offset += size_Float32;
    tmp[2] = view.getFloat32(offset, true);
    offset += size_Float32;
    this.specular = new Float32Array(tmp);
    tmp[0] = view.getFloat32(offset, true);
    offset += size_Float32;
    tmp[1] = view.getFloat32(offset, true);
    offset += size_Float32;
    tmp[2] = view.getFloat32(offset, true);
    offset += size_Float32;
    this.ambient = new Float32Array(tmp);
    this.toon_index = view.getInt8(offset);
    offset += size_Int8;
    this.edge_flag = view.getUint8(offset);
    offset += size_Uint8;
    this.face_vert_count = view.getUint32(offset, true);
    offset += size_Uint32;
    this.texture_file_name = sjisArrayToString((function() {
      var _i, _results;
      _results = [];
      for (i = _i = 0; _i < 20; i = ++_i) {
        _results.push(view.getUint8(offset + size_Uint8 * i));
      }
      return _results;
    })());
  }

  return PMDMaterial;

})();

PMDMaterial.size = size_Float32 * 11 + size_Uint8 * 2 + size_Uint32 + size_Uint8 * 20;

PMDBone = (function() {
  function PMDBone(buffer, view, offset) {
    var tmp;
    this.name = sjisArrayToString(new Uint8Array(buffer, offset, 20));
    offset += size_Uint8 * 20;
    this.parent_bone_index = view.getUint16(offset, true);
    offset += size_Uint16;
    this.tail_pos_bone_index = view.getUint16(offset, true);
    offset += size_Uint16;
    this.type = view.getUint8(offset);
    offset += size_Uint8;
    this.ik_parent_bone_index = view.getUint16(offset, true);
    offset += size_Uint16;
    tmp = [];
    tmp[0] = view.getFloat32(offset, true);
    offset += size_Float32;
    tmp[1] = view.getFloat32(offset, true);
    offset += size_Float32;
    tmp[2] = -view.getFloat32(offset, true);
    offset += size_Float32;
    this.head_pos = new Float32Array(tmp);
  }

  return PMDBone;

})();

PMDBone.size = size_Uint8 * 21 + size_Uint16 * 3 + size_Float32 * 3;

PMDIK = (function() {
  function PMDIK(buffer, view, offset) {
    var chain_length, i;
    this.bone_index = view.getUint16(offset, true);
    offset += size_Uint16;
    this.target_bone_index = view.getUint16(offset, true);
    offset += size_Uint16;
    chain_length = view.getUint8(offset);
    offset += size_Uint8;
    this.iterations = view.getUint16(offset, true);
    offset += size_Uint16;
    this.control_weight = view.getFloat32(offset, true);
    offset += size_Float32;
    this.child_bones = (function() {
      var _i, _results;
      _results = [];
      for (i = _i = 0; 0 <= chain_length ? _i < chain_length : _i > chain_length; i = 0 <= chain_length ? ++_i : --_i) {
        _results.push(view.getUint16(offset + size_Uint16 * i, true));
      }
      return _results;
    })();
  }

  PMDIK.prototype.getSize = function() {
    return size_Uint16 * 3 + size_Uint8 + size_Float32 + size_Uint16 * this.child_bones.length;
  };

  return PMDIK;

})();

PMDMorph = (function() {
  function PMDMorph(buffer, view, offset) {
    var data, i, vert_count;
    this.name = sjisArrayToString(new Uint8Array(buffer, offset, 20));
    offset += size_Uint8 * 20;
    vert_count = view.getUint32(offset, true);
    offset += size_Uint32;
    this.type = view.getUint8(offset);
    offset += size_Uint8;
    this.vert_data = (function() {
      var _i, _results;
      _results = [];
      for (i = _i = 0; 0 <= vert_count ? _i < vert_count : _i > vert_count; i = 0 <= vert_count ? ++_i : --_i) {
        data = {};
        data.index = view.getUint32(offset, true);
        offset += size_Uint32;
        data.x = view.getFloat32(offset, true);
        offset += size_Float32;
        data.y = view.getFloat32(offset, true);
        offset += size_Float32;
        data.z = -view.getFloat32(offset, true);
        offset += size_Float32;
        _results.push(data);
      }
      return _results;
    })();
  }

  PMDMorph.prototype.getSize = function() {
    return size_Uint8 * 21 + size_Uint32 + (size_Uint32 + size_Float32 * 3) * this.vert_data.length;
  };

  return PMDMorph;

})();

PMDRigidBody = (function() {
  function PMDRigidBody(buffer, view, offset) {
    var tmp;
    this.name = sjisArrayToString(new Uint8Array(buffer, offset, 20));
    offset += size_Uint8 * 20;
    this.rel_bone_index = view.getUint16(offset, true);
    offset += size_Uint16;
    this.group_index = view.getUint8(offset);
    offset += size_Uint8;
    this.group_target = view.getUint8(offset);
    offset += size_Uint8;
    this.shape_type = view.getUint8(offset, true);
    offset += size_Uint8;
    this.shape_w = view.getFloat32(offset, true);
    offset += size_Float32;
    this.shape_h = view.getFloat32(offset, true);
    offset += size_Float32;
    this.shape_d = view.getFloat32(offset, true);
    offset += size_Float32;
    tmp = [];
    tmp[0] = view.getFloat32(offset, true);
    offset += size_Float32;
    tmp[1] = view.getFloat32(offset, true);
    offset += size_Float32;
    tmp[2] = -view.getFloat32(offset, true);
    offset += size_Float32;
    this.pos = new Float32Array(tmp);
    tmp[0] = -view.getFloat32(offset, true);
    offset += size_Float32;
    tmp[1] = -view.getFloat32(offset, true);
    offset += size_Float32;
    tmp[2] = view.getFloat32(offset, true);
    offset += size_Float32;
    this.rot = new Float32Array(tmp);
    this.weight = view.getFloat32(offset, true);
    offset += size_Float32;
    this.pos_dim = view.getFloat32(offset, true);
    offset += size_Float32;
    this.rot_dim = view.getFloat32(offset, true);
    offset += size_Float32;
    this.recoil = view.getFloat32(offset, true);
    offset += size_Float32;
    this.friction = view.getFloat32(offset, true);
    offset += size_Float32;
    this.type = view.getUint8(offset);
    offset += size_Uint8;
  }

  return PMDRigidBody;

})();

PMDRigidBody.size = size_Uint8 * 23 + size_Uint16 * 2 + size_Float32 * 14;

PMDJoint = (function() {
  function PMDJoint(buffer, view, offset) {
    var tmp;
    this.name = sjisArrayToString(new Uint8Array(buffer, offset, 20));
    offset += size_Uint8 * 20;
    this.rigidbody_a = view.getUint32(offset, true);
    offset += size_Uint32;
    this.rigidbody_b = view.getUint32(offset, true);
    offset += size_Uint32;
    tmp = [];
    tmp[0] = view.getFloat32(offset, true);
    offset += size_Float32;
    tmp[1] = view.getFloat32(offset, true);
    offset += size_Float32;
    tmp[2] = -view.getFloat32(offset, true);
    offset += size_Float32;
    this.pos = new Float32Array(tmp);
    tmp[0] = -view.getFloat32(offset, true);
    offset += size_Float32;
    tmp[1] = -view.getFloat32(offset, true);
    offset += size_Float32;
    tmp[2] = view.getFloat32(offset, true);
    offset += size_Float32;
    this.rot = new Float32Array(tmp);
    tmp[0] = view.getFloat32(offset, true);
    offset += size_Float32;
    tmp[1] = view.getFloat32(offset, true);
    offset += size_Float32;
    tmp[2] = -view.getFloat32(offset, true);
    offset += size_Float32;
    this.constrain_pos_1 = new Float32Array(tmp);
    tmp[0] = view.getFloat32(offset, true);
    offset += size_Float32;
    tmp[1] = view.getFloat32(offset, true);
    offset += size_Float32;
    tmp[2] = -view.getFloat32(offset, true);
    offset += size_Float32;
    this.constrain_pos_2 = new Float32Array(tmp);
    tmp[0] = -view.getFloat32(offset, true);
    offset += size_Float32;
    tmp[1] = -view.getFloat32(offset, true);
    offset += size_Float32;
    tmp[2] = view.getFloat32(offset, true);
    offset += size_Float32;
    this.constrain_rot_1 = new Float32Array(tmp);
    tmp[0] = -view.getFloat32(offset, true);
    offset += size_Float32;
    tmp[1] = -view.getFloat32(offset, true);
    offset += size_Float32;
    tmp[2] = view.getFloat32(offset, true);
    offset += size_Float32;
    this.constrain_rot_2 = new Float32Array(tmp);
    tmp[0] = view.getFloat32(offset, true);
    offset += size_Float32;
    tmp[1] = view.getFloat32(offset, true);
    offset += size_Float32;
    tmp[2] = -view.getFloat32(offset, true);
    offset += size_Float32;
    this.spring_pos = new Float32Array(tmp);
    tmp[0] = -view.getFloat32(offset, true);
    offset += size_Float32;
    tmp[1] = -view.getFloat32(offset, true);
    offset += size_Float32;
    tmp[2] = view.getFloat32(offset, true);
    offset += size_Float32;
    this.spring_rot = new Float32Array(tmp);
  }

  return PMDJoint;

})();

PMDJoint.size = size_Int8 * 20 + size_Uint32 * 2 + size_Float32 * 24;

this.MMD.PMDRenderer = (function() {
  function PMDRenderer(mmd, model) {
    this.mmd = mmd;
    this.model = model;
    this.gl = this.mmd.gl;
    this.program = this.mmd.pmdProgram;
    this.vbuffers = {};
    this.initVertices();
    this.initIndices();
    this.initTextures();
    this.initMatrices();
    this.motions = {};
    this.playing = false;
    this.frame = -1;
    return;
  }

  PMDRenderer.prototype.initVertices = function() {
    var bone1, bone2, buffer, data, edge, i, length, model, morphVec, normals, positions1, positions2, rotations1, rotations2, uvs, vectors1, vectors2, vertex, weight, _i, _j, _len, _ref;
    model = this.model;
    length = model.vertices.length;
    weight = new Float32Array(length);
    vectors1 = new Float32Array(3 * length);
    vectors2 = new Float32Array(3 * length);
    rotations1 = new Float32Array(4 * length);
    rotations2 = new Float32Array(4 * length);
    positions1 = new Float32Array(3 * length);
    positions2 = new Float32Array(3 * length);
    morphVec = new Float32Array(3 * length);
    normals = new Float32Array(3 * length);
    uvs = new Float32Array(2 * length);
    edge = new Float32Array(length);
    for (i = _i = 0; 0 <= length ? _i < length : _i > length; i = 0 <= length ? ++_i : --_i) {
      vertex = model.vertices[i];
      bone1 = model.bones[vertex.bone_num1];
      bone2 = model.bones[vertex.bone_num2];
      weight[i] = vertex.bone_weight;
      vectors1[3 * i] = vertex.x - bone1.head_pos[0];
      vectors1[3 * i + 1] = vertex.y - bone1.head_pos[1];
      vectors1[3 * i + 2] = vertex.z - bone1.head_pos[2];
      vectors2[3 * i] = vertex.x - bone2.head_pos[0];
      vectors2[3 * i + 1] = vertex.y - bone2.head_pos[1];
      vectors2[3 * i + 2] = vertex.z - bone2.head_pos[2];
      positions1[3 * i] = bone1.head_pos[0];
      positions1[3 * i + 1] = bone1.head_pos[1];
      positions1[3 * i + 2] = bone1.head_pos[2];
      positions2[3 * i] = bone2.head_pos[0];
      positions2[3 * i + 1] = bone2.head_pos[1];
      positions2[3 * i + 2] = bone2.head_pos[2];
      rotations1[4 * i + 3] = 1;
      rotations2[4 * i + 3] = 1;
      normals[3 * i] = vertex.nx;
      normals[3 * i + 1] = vertex.ny;
      normals[3 * i + 2] = vertex.nz;
      uvs[2 * i] = vertex.u;
      uvs[2 * i + 1] = vertex.v;
      edge[i] = 1 - vertex.edge_flag;
    }
    model.rotations1 = rotations1;
    model.rotations2 = rotations2;
    model.positions1 = positions1;
    model.positions2 = positions2;
    model.morphVec = morphVec;
    _ref = [
      {
        attribute: 'aBoneWeight',
        array: weight,
        size: 1
      }, {
        attribute: 'aVectorFromBone1',
        array: vectors1,
        size: 3
      }, {
        attribute: 'aVectorFromBone2',
        array: vectors2,
        size: 3
      }, {
        attribute: 'aBone1Rotation',
        array: rotations1,
        size: 4
      }, {
        attribute: 'aBone2Rotation',
        array: rotations2,
        size: 4
      }, {
        attribute: 'aBone1Position',
        array: positions1,
        size: 3
      }, {
        attribute: 'aBone2Position',
        array: positions2,
        size: 3
      }, {
        attribute: 'aMultiPurposeVector',
        array: morphVec,
        size: 3
      }, {
        attribute: 'aVertexNormal',
        array: normals,
        size: 3
      }, {
        attribute: 'aTextureCoord',
        array: uvs,
        size: 2
      }, {
        attribute: 'aVertexEdge',
        array: edge,
        size: 1
      }
    ];
    for (_j = 0, _len = _ref.length; _j < _len; _j++) {
      data = _ref[_j];
      buffer = this.gl.createBuffer();
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, buffer);
      this.gl.bufferData(this.gl.ARRAY_BUFFER, data.array, this.gl.STATIC_DRAW);
      this.vbuffers[data.attribute] = {
        size: data.size,
        buffer: buffer
      };
    }
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);
  };

  PMDRenderer.prototype.initIndices = function() {
    var indices;
    indices = this.model.triangles;
    this.ibuffer = this.gl.createBuffer();
    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.ibuffer);
    this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, indices, this.gl.STATIC_DRAW);
    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, null);
  };

  PMDRenderer.prototype.initTextures = function() {
    var fileName, material, model, toonIndex, type, _i, _j, _len, _len1, _ref, _ref1;
    model = this.model;
    this.textureManager = new MMD.TextureManager(this.mmd);
    this.textureManager.onload = (function(_this) {
      return function() {
        return _this.redraw = true;
      };
    })(this);
    _ref = model.materials;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      material = _ref[_i];
      if (!material.textures) {
        material.textures = {};
      }
      toonIndex = material.toon_index;
      fileName = 'toon' + ('0' + (toonIndex + 1)).slice(-2) + '.bmp';
      if (toonIndex === -1 || !model.toon_file_names || fileName === model.toon_file_names[toonIndex]) {
        fileName = 'data/' + fileName;
      } else {
        fileName = model.directory + '/' + model.toon_file_names[toonIndex];
      }
      material.textures.toon = this.textureManager.get('toon', fileName);
      if (material.texture_file_name) {
        _ref1 = material.texture_file_name.split('*');
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          fileName = _ref1[_j];
          switch (fileName.slice(-4)) {
            case '.sph':
              type = 'sph';
              break;
            case '.spa':
              type = 'spa';
              break;
            case '.tga':
              type = 'regular';
              fileName += '.png';
              break;
            default:
              type = 'regular';
          }
          material.textures[type] = this.textureManager.get(type, model.directory + '/' + fileName);
        }
      }
    }
  };

  PMDRenderer.prototype.render = function() {
    var attribute, material, offset, vb, _i, _j, _len, _len1, _ref, _ref1, _ref2;
    this.mmd.setPMDUniforms();
    this.program = this.mmd.pmdProgram;
    _ref = this.vbuffers;
    for (attribute in _ref) {
      vb = _ref[attribute];
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, vb.buffer);
      this.gl.vertexAttribPointer(this.program[attribute], vb.size, this.gl.FLOAT, false, 0, 0);
    }
    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.ibuffer);
    this.gl.enable(this.gl.CULL_FACE);
    this.gl.enable(this.gl.BLEND);
    this.gl.blendFuncSeparate(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA, this.gl.SRC_ALPHA, this.gl.DST_ALPHA);
    offset = 0;
    _ref1 = this.model.materials;
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      material = _ref1[_i];
      this.renderMaterial(material, offset);
      offset += material.face_vert_count;
    }
    this.gl.disable(this.gl.BLEND);
    offset = 0;
    _ref2 = this.model.materials;
    for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
      material = _ref2[_j];
      this.renderEdge(material, offset);
      offset += material.face_vert_count;
    }
    return this.gl.useProgram(null);
  };

  PMDRenderer.prototype.renderMaterial = function(material, offset) {
    var textures;
    this.gl.uniform3fv(this.program.uAmbientColor, material.ambient);
    this.gl.uniform3fv(this.program.uSpecularColor, material.specular);
    this.gl.uniform3fv(this.program.uDiffuseColor, material.diffuse);
    this.gl.uniform1f(this.program.uAlpha, material.alpha);
    this.gl.uniform1f(this.program.uShininess, material.shininess);
    this.gl.uniform1i(this.program.uEdge, false);
    textures = material.textures;
    this.gl.activeTexture(this.gl.TEXTURE0);
    this.gl.bindTexture(this.gl.TEXTURE_2D, textures.toon);
    this.gl.uniform1i(this.program.uToon, 0);
    if (textures.regular) {
      this.gl.activeTexture(this.gl.TEXTURE1);
      this.gl.bindTexture(this.gl.TEXTURE_2D, textures.regular);
      this.gl.uniform1i(this.program.uTexture, 1);
    }
    this.gl.uniform1i(this.program.uUseTexture, !!textures.regular);
    if (textures.sph || textures.spa) {
      this.gl.activeTexture(this.gl.TEXTURE2);
      this.gl.bindTexture(this.gl.TEXTURE_2D, textures.sph || textures.spa);
      this.gl.uniform1i(this.program.uSphereMap, 2);
      this.gl.uniform1i(this.program.uUseSphereMap, true);
      this.gl.uniform1i(this.program.uIsSphereMapAdditive, !!textures.spa);
    } else {
      this.gl.uniform1i(this.program.uUseSphereMap, false);
    }
    this.gl.cullFace(this.gl.BACK);
    this.gl.drawElements(this.gl.TRIANGLES, material.face_vert_count, this.gl.UNSIGNED_SHORT, offset * 2);
  };

  PMDRenderer.prototype.renderEdge = function(material, offset) {
    if (!this.drawEdge || !material.edge_flag) {
      return;
    }
    this.gl.uniform1i(this.program.uEdge, true);
    this.gl.cullFace(this.gl.FRONT);
    this.gl.drawElements(this.gl.TRIANGLES, material.face_vert_count, this.gl.UNSIGNED_SHORT, offset * 2);
    this.gl.cullFace(this.gl.BACK);
    return this.gl.uniform1i(this.program.uEdge, false);
  };

  PMDRenderer.prototype.setSelfShadowTexture = function() {
    var material, model, offset, _i, _len, _ref, _ref1;
    if (!this.mmd.drawSelfShadow) {
      return;
    }
    this.shadowMap = this.mmd.shadowMap;
    model = this.model;
    this.shadowMap.computeMatrices();
    this.shadowMap.beforeRender();
    offset = 0;
    _ref = model.materials;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      material = _ref[_i];
      if ((0.979 < (_ref1 = material.alpha) && _ref1 < 0.981)) {
        continue;
      }
      this.gl.drawElements(this.gl.TRIANGLES, material.face_vert_count, this.gl.UNSIGNED_SHORT, offset * 2);
      offset += material.face_vert_count;
    }
    this.shadowMap.afterRender();
    this.gl.activeTexture(this.gl.TEXTURE3);
    this.gl.bindTexture(this.gl.TEXTURE_2D, this.shadowMap.getTexture());
    this.gl.uniform1i(this.program.uShadowMap, 3);
    this.gl.uniformMatrix4fv(this.program.uLightMatrix, false, this.shadowMap.getLightMatrix());
    this.gl.uniform1i(this.program.uSelfShadow, true);
  };

  PMDRenderer.prototype.move = function() {
    if (!this.playing || !this.motionManager) {
      return;
    }
    if (++this.frame > this.motionManager.lastFrame) {
      this.frame = -1;
      this.playing = false;
      return;
    }
    this.moveModel();
  };

  PMDRenderer.prototype.moveModel = function() {
    var bones, morphs, _ref;
    _ref = this.motionManager.getModelFrame(this.model, this.frame), morphs = _ref.morphs, bones = _ref.bones;
    this.moveMorphs(this.model, morphs);
    this.moveBones(this.model, bones);
  };

  PMDRenderer.prototype.moveMorphs = function(model, morphs) {
    var b, base, i, j, morph, vert, weight, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
    if (!morphs) {
      return;
    }
    if (model.morphs.length === 0) {
      return;
    }
    _ref = model.morphs;
    for (j = _i = 0, _len = _ref.length; _i < _len; j = ++_i) {
      morph = _ref[j];
      if (j === 0) {
        base = morph;
        continue;
      }
      if (!(morph.name in morphs)) {
        continue;
      }
      weight = morphs[morph.name];
      _ref1 = morph.vert_data;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        vert = _ref1[_j];
        b = base.vert_data[vert.index];
        i = b.index;
        model.morphVec[3 * i] += vert.x * weight;
        model.morphVec[3 * i + 1] += vert.y * weight;
        model.morphVec[3 * i + 2] += vert.z * weight;
      }
    }
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vbuffers.aMultiPurposeVector.buffer);
    this.gl.bufferData(this.gl.ARRAY_BUFFER, model.morphVec, this.gl.STATIC_DRAW);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);
    _ref2 = base.vert_data;
    for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
      b = _ref2[_k];
      i = b.index;
      model.morphVec[3 * i] = 0;
      model.morphVec[3 * i + 1] = 0;
      model.morphVec[3 * i + 2] = 0;
    }
  };

  PMDRenderer.prototype.moveBones = function(model, bones) {
    var bone, boneMotions, constrainedBones, getBoneMotion, i, individualBoneMotions, length, motion1, motion2, originalBonePositions, parentBones, pos1, pos2, positions1, positions2, resolveIKs, rot1, rot2, rotations1, rotations2, vertex, _i, _j, _k, _len, _ref, _ref1, _ref2;
    if (!bones) {
      return;
    }
    individualBoneMotions = [];
    boneMotions = [];
    originalBonePositions = [];
    parentBones = [];
    constrainedBones = [];
    _ref = model.bones;
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      bone = _ref[i];
      individualBoneMotions[i] = (_ref1 = bones[bone.name]) != null ? _ref1 : {
        rotation: quat4.create([0, 0, 0, 1]),
        location: vec3.create()
      };
      boneMotions[i] = {
        r: quat4.create(),
        p: vec3.create(),
        tainted: true
      };
      originalBonePositions[i] = bone.head_pos;
      parentBones[i] = bone.parent_bone_index;
      if (bone.name.indexOf('\u3072\u3056') > 0) {
        constrainedBones[i] = true;
      }
    }
    getBoneMotion = function(boneIndex) {
      var m, motion, p, parentIndex, parentMotion, r, t;
      motion = boneMotions[boneIndex];
      if (motion && !motion.tainted) {
        return motion;
      }
      m = individualBoneMotions[boneIndex];
      r = quat4.set(m.rotation, motion.r);
      t = m.location;
      p = vec3.set(originalBonePositions[boneIndex], motion.p);
      if (parentBones[boneIndex] === 0xFFFF) {
        return boneMotions[boneIndex] = {
          p: vec3.add(p, t),
          r: r,
          tainted: false
        };
      } else {
        parentIndex = parentBones[boneIndex];
        parentMotion = getBoneMotion(parentIndex);
        r = quat4.multiply(parentMotion.r, r, r);
        p = vec3.subtract(p, originalBonePositions[parentIndex]);
        vec3.add(p, t);
        vec3.rotateByQuat4(p, parentMotion.r);
        vec3.add(p, parentMotion.p);
        return boneMotions[boneIndex] = {
          p: p,
          r: r,
          tainted: false
        };
      }
    };
    resolveIKs = function() {
      var axis, axisLen, boneIndex, bonePos, c, ik, ikbonePos, ikboneVec, ikboneVecLen, j, maxangle, minLength, motion, n, parentRotation, q, r, sinTheta, targetIndex, targetPos, targetVec, targetVecLen, theta, tmpQ, tmpR, _j, _len1, _ref2, _results;
      targetVec = vec3.create();
      ikboneVec = vec3.create();
      axis = vec3.create();
      tmpQ = quat4.create();
      tmpR = quat4.create();
      _ref2 = model.iks;
      _results = [];
      for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
        ik = _ref2[_j];
        ikbonePos = getBoneMotion(ik.bone_index).p;
        targetIndex = ik.target_bone_index;
        minLength = 0.1 * vec3.length(vec3.subtract(originalBonePositions[targetIndex], originalBonePositions[parentBones[targetIndex]], axis));
        _results.push((function() {
          var _k, _ref3, _results1;
          _results1 = [];
          for (n = _k = 0, _ref3 = ik.iterations; 0 <= _ref3 ? _k < _ref3 : _k > _ref3; n = 0 <= _ref3 ? ++_k : --_k) {
            targetPos = getBoneMotion(targetIndex).p;
            if (minLength > vec3.length(vec3.subtract(targetPos, ikbonePos, axis))) {
              break;
            }
            _results1.push((function() {
              var _l, _len2, _m, _ref4, _results2;
              _ref4 = ik.child_bones;
              _results2 = [];
              for (i = _l = 0, _len2 = _ref4.length; _l < _len2; i = ++_l) {
                boneIndex = _ref4[i];
                motion = getBoneMotion(boneIndex);
                bonePos = motion.p;
                if (i > 0) {
                  targetPos = getBoneMotion(targetIndex).p;
                }
                targetVec = vec3.subtract(targetPos, bonePos, targetVec);
                targetVecLen = vec3.length(targetVec);
                if (targetVecLen < minLength) {
                  continue;
                }
                ikboneVec = vec3.subtract(ikbonePos, bonePos, ikboneVec);
                ikboneVecLen = vec3.length(ikboneVec);
                if (ikboneVecLen < minLength) {
                  continue;
                }
                axis = vec3.cross(targetVec, ikboneVec, axis);
                axisLen = vec3.length(axis);
                sinTheta = axisLen / ikboneVecLen / targetVecLen;
                if (sinTheta < 0.001) {
                  continue;
                }
                maxangle = (i + 1) * ik.control_weight * 4;
                theta = Math.asin(sinTheta);
                if (vec3.dot(targetVec, ikboneVec) < 0) {
                  theta = 3.141592653589793 - theta;
                }
                if (theta > maxangle) {
                  theta = maxangle;
                }
                q = quat4.set(vec3.scale(axis, Math.sin(theta / 2) / axisLen), tmpQ);
                q[3] = Math.cos(theta / 2);
                parentRotation = getBoneMotion(parentBones[boneIndex]).r;
                r = quat4.inverse(parentRotation, tmpR);
                r = quat4.multiply(quat4.multiply(r, q), motion.r);
                if (constrainedBones[boneIndex]) {
                  c = r[3];
                  r = quat4.set([Math.sqrt(1 - c * c), 0, 0, c], r);
                  quat4.inverse(boneMotions[boneIndex].r, q);
                  quat4.multiply(r, q, q);
                  q = quat4.multiply(parentRotation, q, q);
                }
                quat4.normalize(r, individualBoneMotions[boneIndex].rotation);
                quat4.multiply(q, motion.r, motion.r);
                for (j = _m = 0; 0 <= i ? _m < i : _m > i; j = 0 <= i ? ++_m : --_m) {
                  boneMotions[ik.child_bones[j]].tainted = true;
                }
                _results2.push(boneMotions[ik.target_bone_index].tainted = true);
              }
              return _results2;
            })());
          }
          return _results1;
        })());
      }
      return _results;
    };
    resolveIKs();
    for (i = _j = 0, _ref2 = model.bones.length; 0 <= _ref2 ? _j < _ref2 : _j > _ref2; i = 0 <= _ref2 ? ++_j : --_j) {
      getBoneMotion(i);
    }
    rotations1 = model.rotations1;
    rotations2 = model.rotations2;
    positions1 = model.positions1;
    positions2 = model.positions2;
    length = model.vertices.length;
    for (i = _k = 0; 0 <= length ? _k < length : _k > length; i = 0 <= length ? ++_k : --_k) {
      vertex = model.vertices[i];
      motion1 = boneMotions[vertex.bone_num1];
      motion2 = boneMotions[vertex.bone_num2];
      rot1 = motion1.r;
      pos1 = motion1.p;
      rot2 = motion2.r;
      pos2 = motion2.p;
      rotations1[i * 4] = rot1[0];
      rotations1[i * 4 + 1] = rot1[1];
      rotations1[i * 4 + 2] = rot1[2];
      rotations1[i * 4 + 3] = rot1[3];
      rotations2[i * 4] = rot2[0];
      rotations2[i * 4 + 1] = rot2[1];
      rotations2[i * 4 + 2] = rot2[2];
      rotations2[i * 4 + 3] = rot2[3];
      positions1[i * 3] = pos1[0];
      positions1[i * 3 + 1] = pos1[1];
      positions1[i * 3 + 2] = pos1[2];
      positions2[i * 3] = pos2[0];
      positions2[i * 3 + 1] = pos2[1];
      positions2[i * 3 + 2] = pos2[2];
    }
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vbuffers.aBone1Rotation.buffer);
    this.gl.bufferData(this.gl.ARRAY_BUFFER, rotations1, this.gl.STATIC_DRAW);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vbuffers.aBone2Rotation.buffer);
    this.gl.bufferData(this.gl.ARRAY_BUFFER, rotations2, this.gl.STATIC_DRAW);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vbuffers.aBone1Position.buffer);
    this.gl.bufferData(this.gl.ARRAY_BUFFER, positions1, this.gl.STATIC_DRAW);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vbuffers.aBone2Position.buffer);
    this.gl.bufferData(this.gl.ARRAY_BUFFER, positions2, this.gl.STATIC_DRAW);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);
  };

  PMDRenderer.prototype.initMatrices = function() {
    return this.modelMatrix = mat4.createIdentity();
  };

  PMDRenderer.prototype.translate = function(x, y, z) {
    return mat4.translate(this.modelMatrix, [x, y, z]);
  };

  PMDRenderer.prototype.scale = function(x, y, z) {
    return mat4.scale(this.modelMatrix, [x, y, z]);
  };

  PMDRenderer.prototype.rotate = function(angle, x, y, z) {
    return mat4.rotate(this.modelMatrix, angle, [x, y, z]);
  };

  PMDRenderer.prototype.addModelMotion = function(motionName, motion, merge_flag, frame_offset) {
    var motionManager;
    motionManager = new MMD.MotionManager;
    motionManager.addModelMotion(this.model, motion, merge_flag, frame_offset);
    return this.motions[motionName] = motionManager;
  };

  PMDRenderer.prototype.play = function(motionName) {
    this.playing = true;
    this.motionManager = this.motions[motionName];
    if (!this.motionManager) {
      console.log("" + motionName + " not found in the motions");
    }
    return this.frame = -1;
  };

  return PMDRenderer;

})();

size_Int8 = Int8Array.BYTES_PER_ELEMENT;

size_Uint8 = Uint8Array.BYTES_PER_ELEMENT;

size_Uint16 = Uint16Array.BYTES_PER_ELEMENT;

size_Uint32 = Uint32Array.BYTES_PER_ELEMENT;

size_Float32 = Float32Array.BYTES_PER_ELEMENT;

slice = Array.prototype.slice;

DataView.prototype.getBySize = function(offset, size, littleEndian) {
  if (littleEndian == null) {
    littleEndian = false;
  }
  switch (size) {
    case size_Uint8:
      return this.getInt8(offset);
    case size_Uint16:
      return this.getInt16(offset, littleEndian);
    case size_Uint32:
      return this.getInt32(offset, littleEndian);
    default:
      throw "unsupported size " + size;
  }
};

DataView.prototype.getString = function(offset, size, utf8Encoding) {
  var i, ret, _i, _j;
  if (utf8Encoding == null) {
    utf8Encoding = false;
  }
  ret = "";
  if (utf8Encoding) {
    for (i = _i = 0; 0 <= size ? _i < size : _i > size; i = 0 <= size ? ++_i : --_i) {
      ret += String.fromCharCode(this.getUint8(offset + i * size_Uint8));
    }
  } else {
    size = size / 2;
    for (i = _j = 0; 0 <= size ? _j < size : _j > size; i = 0 <= size ? ++_j : --_j) {
      ret += String.fromCharCode(this.getUint16(offset + i * size_Uint16, true));
    }
  }
  return ret;
};

this.MMD.PMXModel = (function() {
  function PMXModel(directory, filename) {
    this.type = "PMX";
    this.directory = directory;
    this.filename = filename;
    this.vertices = null;
    this.triangles = null;
    this.materials = null;
    this.textures = null;
    this.bones = null;
    this.morphs = null;
    this.morph_order = null;
    this.bone_group_names = null;
    this.bone_table = null;
    this.english_flag = null;
    this.english_name = null;
    this.english_comment = null;
    this.english_bone_names = null;
    this.english_morph_names = null;
    this.english_bone_group_names = null;
    this.toon_file_names = null;
    this.rigid_bodies = null;
    this.joints = null;
    this.encoding = null;
    this.utf8encoding = null;
    this.appendix_uv = null;
    this.vertex_index_size = null;
    this.texture_index_size = null;
    this.material_index_size = null;
    this.bone_index_size = null;
    this.morph_index_size = null;
    this.rigid_body_index_size = null;
  }

  PMXModel.prototype.load = function(callback) {
    var xhr;
    xhr = new XMLHttpRequest;
    xhr.open('GET', this.directory + '/' + this.filename, true);
    xhr.responseType = 'arraybuffer';
    xhr.onload = (function(_this) {
      return function() {
        console.time("parse " + _this.filename);
        _this.parse(xhr.response);
        console.timeEnd("parse " + _this.filename);
        return callback();
      };
    })(this);
    return xhr.send();
  };

  PMXModel.prototype.parse = function(buffer) {
    var length, offset, view;
    length = buffer.byteLength;
    view = new DataView(buffer, 0);
    offset = 0;
    offset = this.checkHeader(buffer, view, offset);
    offset = this.getName(buffer, view, offset);
    offset = this.getVertices(buffer, view, offset);
    offset = this.getTriangles(buffer, view, offset);
    offset = this.getTextures(buffer, view, offset);
    offset = this.getMaterials(buffer, view, offset);
    offset = this.getBones(buffer, view, offset);
    offset = this.getMorphs(buffer, view, offset);
    offset = this.getFrames(buffer, view, offset);
    offset = this.getRigidBodies(buffer, view, offset);
    return offset = this.getJoints(buffer, view, offset);
  };

  PMXModel.prototype.checkHeader = function(buffer, view, offset) {
    if (view.getUint8(0) !== 'P'.charCodeAt(0) || view.getUint8(1) !== 'M'.charCodeAt(0) || view.getUint8(2) !== 'X'.charCodeAt(0) || view.getUint8(3) !== ' '.charCodeAt(0) || view.getUint8(4) !== 0x00 || view.getUint8(5) !== 0x00 || view.getUint8(6) !== 0x00 || view.getUint8(7) !== 0x40) {
      throw 'File is not PMX';
    }
    this.length = view.getUint8(8);
    this.encoding = view.getUint8(9) === 0 ? "UTF-16" : "UTF-8";
    this.utf8encoding = Boolean(view.getUint8(9));
    this.appendix_uv = view.getUint8(10);
    this.vertex_index_size = view.getUint8(11);
    this.texture_index_size = view.getUint8(12);
    this.material_index_size = view.getUint8(13);
    this.bone_index_size = view.getUint8(14);
    this.morph_index_size = view.getUint8(15);
    this.rigid_body_index_size = view.getUint8(16);
    return offset += 17 * size_Uint8;
  };

  PMXModel.prototype.getName = function(buffer, view, offset) {
    var length;
    length = view.getUint32(offset, true);
    this.name = view.getString(offset + size_Uint32, length, this.utf8encoding);
    offset += length * size_Uint8 + size_Uint32;
    length = view.getUint32(offset, true);
    this.english_name = view.getString(offset + size_Uint32, length, this.utf8encoding);
    offset += length * size_Uint8 + size_Uint32;
    length = view.getUint32(offset, true);
    this.comment = view.getString(offset + size_Uint32, length, this.utf8encoding);
    offset += length * size_Uint8 + size_Uint32;
    length = view.getUint32(offset, true);
    this.english_comment = view.getString(offset + size_Uint32, length, this.utf8encoding);
    return offset += length * size_Uint8 + size_Uint32;
  };

  PMXModel.prototype.getVertices = function(buffer, view, offset) {
    var i, length, vertex;
    length = view.getUint32(offset, true);
    offset += size_Uint32;
    this.vertices = (function() {
      var _i, _results;
      _results = [];
      for (i = _i = 0; 0 <= length ? _i < length : _i > length; i = 0 <= length ? ++_i : --_i) {
        vertex = new PMXVertex(buffer, view, offset, this);
        offset += vertex.size;
        _results.push(vertex);
      }
      return _results;
    }).call(this);
    return offset;
  };

  PMXModel.prototype.getTriangles = function(buffer, view, offset) {
    var i, length, _i;
    length = view.getUint32(offset, true);
    offset += size_Uint32;
    this.triangles = new Uint16Array(length);
    for (i = _i = 0; _i < length; i = _i += 3) {
      this.triangles[i + 1] = view.getBySize(offset, this.vertex_index_size, true);
      offset += this.vertex_index_size;
      this.triangles[i] = view.getBySize(offset, this.vertex_index_size, true);
      offset += this.vertex_index_size;
      this.triangles[i + 2] = view.getBySize(offset, this.vertex_index_size, true);
      offset += this.vertex_index_size;
    }
    return offset;
  };

  PMXModel.prototype.getTextures = function(buffer, view, offset) {
    var i, len, length, texture;
    length = view.getUint32(offset, true);
    offset += size_Uint32;
    this.textures = (function() {
      var _i, _results;
      _results = [];
      for (i = _i = 0; 0 <= length ? _i < length : _i > length; i = 0 <= length ? ++_i : --_i) {
        len = view.getUint32(offset, true);
        texture = view.getString(offset + size_Uint32, len, this.utf8Encoding);
        offset += size_Uint32 + len * size_Uint8;
        _results.push(texture);
      }
      return _results;
    }).call(this);
    return offset;
  };

  PMXModel.prototype.getMaterials = function(buffer, view, offset) {
    var i, length, material;
    length = view.getUint32(offset, true);
    offset += size_Uint32;
    this.materials = (function() {
      var _i, _results;
      _results = [];
      for (i = _i = 0; 0 <= length ? _i < length : _i > length; i = 0 <= length ? ++_i : --_i) {
        material = new PMXMaterial(buffer, view, offset, this);
        offset += material.size;
        _results.push(material);
      }
      return _results;
    }).call(this);
    return offset;
  };

  PMXModel.prototype.getBones = function(buffer, view, offset) {
    var bone, i, length;
    length = view.getUint32(offset, true);
    offset += size_Uint32;
    this.bones = (function() {
      var _i, _results;
      _results = [];
      for (i = _i = 0; 0 <= length ? _i < length : _i > length; i = 0 <= length ? ++_i : --_i) {
        bone = new PMXBone(buffer, view, offset, this);
        offset += bone.size;
        _results.push(bone);
      }
      return _results;
    }).call(this);
    return offset;
  };

  PMXModel.prototype.getMorphs = function(buffer, view, offset) {
    var i, length, morph;
    length = view.getUint32(offset, true);
    offset += size_Uint32;
    this.morphs = (function() {
      var _i, _results;
      _results = [];
      for (i = _i = 0; 0 <= length ? _i < length : _i > length; i = 0 <= length ? ++_i : --_i) {
        morph = new PMXMorph(buffer, view, offset, this);
        offset += morph.size;
        _results.push(morph);
      }
      return _results;
    }).call(this);
    return offset;
  };

  PMXModel.prototype.getFrames = function(buffer, view, offset) {
    var frame, i, length;
    length = view.getUint32(offset, true);
    offset += size_Uint32;
    this.frames = (function() {
      var _i, _results;
      _results = [];
      for (i = _i = 0; 0 <= length ? _i < length : _i > length; i = 0 <= length ? ++_i : --_i) {
        frame = new PMXFrame(buffer, view, offset, this);
        offset += frame.size;
        _results.push(frame);
      }
      return _results;
    }).call(this);
    return offset;
  };

  PMXModel.prototype.getRigidBodies = function(buffer, view, offset) {
    var i, length, rigid_body;
    length = view.getUint32(offset, true);
    offset += size_Uint32;
    this.rigid_bodies = (function() {
      var _i, _results;
      _results = [];
      for (i = _i = 0; 0 <= length ? _i < length : _i > length; i = 0 <= length ? ++_i : --_i) {
        rigid_body = new PMXRigidBody(buffer, view, offset, this);
        offset += rigid_body.size;
        _results.push(rigid_body);
      }
      return _results;
    }).call(this);
    return offset;
  };

  PMXModel.prototype.getJoints = function(buffer, view, offset) {
    var i, joint, length;
    length = view.getUint32(offset, true);
    offset += size_Uint32;
    this.joints = (function() {
      var _i, _results;
      _results = [];
      for (i = _i = 0; 0 <= length ? _i < length : _i > length; i = 0 <= length ? ++_i : --_i) {
        joint = new PMXJoint(buffer, view, offset, this);
        offset += joint.size;
        _results.push(joint);
      }
      return _results;
    }).call(this);
    return offset;
  };

  return PMXModel;

})();

PMXVertex = (function() {
  PMXVertex.BDEF1 = 0;

  PMXVertex.BDEF2 = 1;

  PMXVertex.BDEF4 = 2;

  PMXVertex.SDEF = 3;

  function PMXVertex(buffer, view, offset, model) {
    var i, _offset;
    _offset = offset;
    this.x = view.getFloat32(offset, true);
    offset += size_Float32;
    this.y = view.getFloat32(offset, true);
    offset += size_Float32;
    this.z = -view.getFloat32(offset, true);
    offset += size_Float32;
    this.nx = view.getFloat32(offset, true);
    offset += size_Float32;
    this.ny = view.getFloat32(offset, true);
    offset += size_Float32;
    this.nz = -view.getFloat32(offset, true);
    offset += size_Float32;
    this.u = view.getFloat32(offset, true);
    offset += size_Float32;
    this.v = view.getFloat32(offset, true);
    offset += size_Float32;
    this.appendix_uv = (function() {
      var _i, _ref, _results;
      _results = [];
      for (i = _i = 0, _ref = model.appendix_uv; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        view.getFloat32(offset, true);
        _results.push(offset += size_Float32);
      }
      return _results;
    })();
    this.weight_type = view.getUint8(offset, true);
    offset += size_Uint8;
    switch (this.weight_type) {
      case PMXVertex.BDEF1:
        this.bone_num1 = view.getBySize(offset, model.bone_index_size, true);
        offset += model.bone_index_size;
        break;
      case PMXVertex.BDEF2:
        this.bone_num1 = view.getBySize(offset, model.bone_index_size, true);
        offset += model.bone_index_size;
        this.bone_num2 = view.getBySize(offset, model.bone_index_size, true);
        offset += model.bone_index_size;
        this.bone_weight1 = view.getFloat32(offset, true);
        offset += size_Float32;
        break;
      case PMXVertex.BDEF4:
        this.bone_num1 = view.getBySize(offset, model.bone_index_size, true);
        offset += model.bone_index_size;
        this.bone_num2 = view.getBySize(offset, model.bone_index_size, true);
        offset += model.bone_index_size;
        this.bone_num3 = view.getBySize(offset, model.bone_index_size, true);
        offset += model.bone_index_size;
        this.bone_num4 = view.getBySize(offset, model.bone_index_size, true);
        offset += model.bone_index_size;
        this.bone_weight1 = view.getFloat32(offset, true);
        offset += size_Float32;
        this.bone_weight2 = view.getFloat32(offset, true);
        offset += size_Float32;
        this.bone_weight3 = view.getFloat32(offset, true);
        offset += size_Float32;
        this.bone_weight4 = view.getFloat32(offset, true);
        offset += size_Float32;
        break;
      case PMXVertex.SDEF:
        this.bone_num1 = view.getBySize(offset, model.bone_index_size, true);
        offset += model.bone_index_size;
        this.bone_num2 = view.getBySize(offset, model.bone_index_size, true);
        offset += model.bone_index_size;
        this.bone_weight1 = view.getFloat32(offset, true);
        offset += size_Float32;
        this.C = new Float32Array([view.getFloat32(offset, true), view.getFloat32(offset + size_Float32, true), view.getFloat32(offset + size_Float32 * 2, true)]);
        offset += 3 * size_Float32;
        this.R0 = new Float32Array([view.getFloat32(offset, true), view.getFloat32(offset + size_Float32, true), view.getFloat32(offset + size_Float32 * 2, true)]);
        offset += 3 * size_Float32;
        this.R1 = new Float32Array([view.getFloat32(offset, true), view.getFloat32(offset + size_Float32, true), view.getFloat32(offset + size_Float32 * 2, true)]);
        offset += 3 * size_Float32;
        break;
      default:
        throw "Vertex weight_typpe format error: " + this.weight_type;
    }
    this.edge_scale = view.getFloat32(offset, true);
    offset += size_Float32;
    this.size = offset - _offset;
  }

  return PMXVertex;

})();

PMXMaterial = (function() {
  function PMXMaterial(buffer, view, offset, model) {
    var len, _offset;
    _offset = offset;
    len = view.getUint32(offset, true);
    this.name = view.getString(offset + size_Uint32, len, model.utf8Encoding);
    offset += size_Uint32 + size_Uint8 * len;
    len = view.getUint32(offset, true);
    this.english_name = view.getString(offset + size_Uint32, len, model.utf8Encoding);
    offset += size_Uint32 + size_Uint8 * len;
    this.diffuse = new Float32Array([view.getFloat32(offset, true), view.getFloat32(offset + size_Float32, true), view.getFloat32(offset + size_Float32 * 2, true)]);
    offset += 3 * size_Float32;
    this.alpha = view.getFloat32(offset, true);
    offset += size_Float32;
    this.specular = new Float32Array([view.getFloat32(offset, true), view.getFloat32(offset + size_Float32, true), view.getFloat32(offset + size_Float32 * 2, true)]);
    offset += 3 * size_Float32;
    this.shininess = view.getFloat32(offset, true);
    offset += size_Float32;
    this.ambient = new Float32Array([view.getFloat32(offset, true), view.getFloat32(offset + size_Float32, true), view.getFloat32(offset + size_Float32 * 2, true)]);
    offset += 3 * size_Float32;
    this.bit_flag = view.getUint8(offset);
    offset += size_Uint8;
    this.edge_color = new Float32Array([view.getFloat32(offset, true), view.getFloat32(offset + size_Float32, true), view.getFloat32(offset + size_Float32 * 2, true), view.getFloat32(offset + size_Float32 * 3, true)]);
    offset += 4 * size_Float32;
    this.edge_size = view.getFloat32(offset, true);
    offset += size_Float32;
    this.texture_index = view.getBySize(offset, model.texture_index_size, true);
    offset += model.texture_index_size;
    this.texture_file_name = model.textures[this.texture_index];
    this.sphere_index = view.getBySize(offset, model.texture_index_size, true);
    offset += model.texture_index_size;
    this.sphere_mode = view.getUint8(offset);
    offset += size_Uint8;
    this.toon_flag = view.getUint8(offset);
    offset += size_Uint8;
    if (Boolean(this.toon_flag)) {
      this.toon_index = view.getUint8(offset);
      offset += size_Uint8;
    } else {
      this.toon_index = view.getBySize(offset, model.material_index_size, true);
      offset += model.material_index_size;
    }
    len = view.getUint32(offset, true);
    this.memo = view.getString(offset + size_Uint32, len, model.utf8Encoding);
    offset += size_Uint32 + size_Uint8 * len;
    this.face_vert_count = view.getUint32(offset, true);
    offset += size_Uint32;
    this.size = offset - _offset;
  }

  return PMXMaterial;

})();

PMXBone = (function() {
  function PMXBone(buffer, view, offset, model) {
    var bit_flag, chain_length, child_bone, i, len, _i, _offset;
    _offset = offset;
    len = view.getUint32(offset, true);
    this.name = view.getString(offset + size_Uint32, len, model.utf8Encoding);
    offset += size_Uint32 + size_Uint8 * len;
    len = view.getUint32(offset, true);
    this.english_name = view.getString(offset + size_Uint32, len, model.utf8Encoding);
    offset += size_Uint32 + size_Uint8 * len;
    this.head_pos = new Float32Array([view.getFloat32(offset, true), view.getFloat32(offset + size_Float32, true), view.getFloat32(offset + size_Float32 * 2, true)]);
    offset += 3 * size_Float32;
    this.parent_bone_index = view.getBySize(offset, model.bone_index_size, true);
    offset += model.bone_index_size;
    this.morph_bone_index = view.getInt32(offset, true);
    offset += size_Uint32;
    bit_flag = view.getUint16(offset, true);
    offset += size_Uint16;
    if (bit_flag & 0x1) {
      this.connect_index = view.getBySize(offset, model.bone_index_size);
      offset += model.bone_index_size;
    } else {
      this.offset = new Float32Array([view.getFloat32(offset, true), view.getFloat32(offset + size_Float32, true), view.getFloat32(offset + size_Float32 * 2, true)]);
      offset += 3 * size_Float32;
    }
    if (bit_flag & 0x0300) {
      this.inverse_parent_index = view.getBySize(offset, model.bone_index_size, true);
      offset += model.bone_index_size;
      this.inverse_rate = view.getFloat32(offset, true);
      offset += size_Float32;
    }
    if (bit_flag & 0x0400) {
      this.axis = new Float32Array([view.getFloat32(offset, true), view.getFloat32(offset + size_Float32, true), view.getFloat32(offset + size_Float32 * 2, true)]);
      offset += 3 * size_Float32;
    }
    if (bit_flag & 0x0800) {
      this.x_axis = new Float32Array([view.getFloat32(offset, true), view.getFloat32(offset + size_Float32, true), view.getFloat32(offset + size_Float32 * 2, true)]);
      offset += 3 * size_Float32;
      this.z_axis = new Float32Array([view.getFloat32(offset, true), view.getFloat32(offset + size_Float32, true), view.getFloat32(offset + size_Float32 * 2, true)]);
      offset += 3 * size_Float32;
    }
    if (bit_flag & 0x2000) {
      this.parent_key = view.getInt32(offset, true);
      offset += size_Uint32;
    }
    if (bit_flag & 0x0020) {
      this.ik_flag = true;
      this.target_bone_index = view.getBySize(offset, model.bone_index_size, true);
      offset += model.bone_index_size;
      this.iterations = view.getUint32(offset, true);
      offset += size_Uint32;
      this.ik_rad_limited = view.getFloat32(offset, true);
      offset += size_Float32;
      chain_length = view.getUint32(offset, true);
      offset += size_Uint32;
      this.child_bones = [];
      for (i = _i = 0; 0 <= chain_length ? _i < chain_length : _i > chain_length; i = 0 <= chain_length ? ++_i : --_i) {
        child_bone = {};
        child_bone['link_index'] = view.getBySize(offset, model.bone_index_size, true);
        offset += model.bone_index_size;
        child_bone['rad_limited'] = view.getUint8(offset);
        offset += size_Uint8;
        if (child_bone['rad_limited']) {
          child_bone['lower_vector'] = new Float32Array([view.getFloat32(offset, true), view.getFloat32(offset + size_Float32, true), view.getFloat32(offset + size_Float32 * 2, true)]);
          offset += 3 * size_Float32;
          child_bone['upper_vector'] = new Float32Array([view.getFloat32(offset, true), view.getFloat32(offset + size_Float32, true), view.getFloat32(offset + size_Float32 * 2, true)]);
          offset += 3 * size_Float32;
        }
        this.child_bones.push(child_bone);
      }
    }
    this.size = offset - _offset;
  }

  return PMXBone;

})();

PMXMorph = (function() {
  function PMXMorph(buffer, view, offset, model) {
    var data, i, len, length, _offset;
    _offset = offset;
    len = view.getUint32(offset, true);
    this.name = view.getString(offset + size_Uint32, len, model.utf8Encoding);
    offset += size_Uint32 + size_Uint8 * len;
    len = view.getUint32(offset, true);
    this.english_name = view.getString(offset + size_Uint32, len, model.utf8Encoding);
    offset += size_Uint32 + size_Uint8 * len;
    this.panel = view.getUint8(offset);
    offset += size_Uint8;
    this.type = view.getUint8(offset);
    offset += size_Uint8;
    length = view.getUint32(offset, true);
    offset += size_Uint32;
    this.offset = (function() {
      var _i, _results;
      _results = [];
      for (i = _i = 0; 0 <= length ? _i < length : _i > length; i = 0 <= length ? ++_i : --_i) {
        data = {};
        switch (this.type) {
          case 0:
            data.morph_index = view.getBySize(offset, model.morph_index_size);
            offset += model.morph_index_size;
            data.morph_rate = view.getFloat32(offset, true);
            offset += size_Float32;
            break;
          case 1:
            data.vertex_index = view.getBySize(offset, model.vertex_index_size);
            offset += model.vertex_index_size;
            data.coordinate = new Float32Array([view.getFloat32(offset, true), view.getFloat32(offset + size_Float32, true), view.getFloat32(offset + size_Float32 * 2, true)]);
            offset += 3 * size_Float32;
            break;
          case 2:
            data.bone_index = view.getBySize(offset, model.bone_index_size);
            offset += model.bone_index_size;
            data.distance = new Float32Array([view.getFloat32(offset, true), view.getFloat32(offset + size_Float32, true), view.getFloat32(offset + size_Float32 * 2, true)]);
            offset += 3 * size_Float32;
            data.turning = new Float32Array([view.getFloat32(offset, true), view.getFloat32(offset + size_Float32, true), view.getFloat32(offset + size_Float32 * 2, true), view.getFloat32(offset + size_Float32 * 3, true)]);
            offset += 4 * size_Float32;
            break;
          case 3:
          case 4:
          case 5:
          case 6:
          case 7:
            data.vertex_index = view.getBySize(offset, model.vertex_index_size);
            offset += model.vertex_index_size;
            data.uv_offset = new Float32Array([view.getFloat32(offset, true), view.getFloat32(offset + size_Float32, true), view.getFloat32(offset + size_Float32 * 2, true), view.getFloat32(offset + size_Float32 * 3, true)]);
            offset += 4 * size_Float32;
            break;
          case 8:
            data.material_index = view.getBySize(offset, model.material_index_size);
            offset += model.material_index_size;
            data.offset_type = view.getUint8(offset);
            offset += size_Uint8;
            data.diffuse = new Float32Array([view.getFloat32(offset, true), view.getFloat32(offset + size_Float32, true), view.getFloat32(offset + size_Float32 * 2, true)]);
            offset += 3 * size_Float32;
            data.alpha = view.getFloat32(offset, true);
            offset += size_Float32;
            data.specular = new Float32Array([view.getFloat32(offset, true), view.getFloat32(offset + size_Float32, true), view.getFloat32(offset + size_Float32 * 2, true)]);
            offset += 3 * size_Float32;
            data.shininess = view.getFloat32(offset, true);
            offset += size_Float32;
            data.ambient = new Float32Array([view.getFloat32(offset, true), view.getFloat32(offset + size_Float32, true), view.getFloat32(offset + size_Float32 * 2, true)]);
            offset += 3 * size_Float32;
            data.edge_color = new Float32Array([view.getFloat32(offset, true), view.getFloat32(offset + size_Float32, true), view.getFloat32(offset + size_Float32 * 2, true), view.getFloat32(offset + size_Float32 * 3, true)]);
            offset += 4 * size_Float32;
            data.edge_size = view.getFloat32(offset, true);
            offset += size_Float32;
            data.texture_mod = new Float32Array([view.getFloat32(offset, true), view.getFloat32(offset + size_Float32, true), view.getFloat32(offset + size_Float32 * 2, true), view.getFloat32(offset + size_Float32 * 3, true)]);
            offset += 4 * size_Float32;
            data.sphere_mod = new Float32Array([view.getFloat32(offset, true), view.getFloat32(offset + size_Float32, true), view.getFloat32(offset + size_Float32 * 2, true), view.getFloat32(offset + size_Float32 * 3, true)]);
            offset += 4 * size_Float32;
            data.toon_mod = new Float32Array([view.getFloat32(offset, true), view.getFloat32(offset + size_Float32, true), view.getFloat32(offset + size_Float32 * 2, true), view.getFloat32(offset + size_Float32 * 3, true)]);
            offset += 4 * size_Float32;
        }
        _results.push(data);
      }
      return _results;
    }).call(this);
    this.size = offset - _offset;
  }

  return PMXMorph;

})();

PMXFrame = (function() {
  function PMXFrame(buffer, view, offset, model) {
    var data, i, len, length, _offset;
    _offset = offset;
    len = view.getUint32(offset, true);
    this.name = view.getString(offset + size_Uint32, len, model.utf8Encoding);
    offset += size_Uint32 + size_Uint8 * len;
    len = view.getUint32(offset, true);
    this.english_name = view.getString(offset + size_Uint32, len, model.utf8Encoding);
    offset += size_Uint32 + size_Uint8 * len;
    this.flag = view.getUint8(offset);
    offset += size_Uint8;
    length = view.getUint32(offset, true);
    offset += size_Uint32;
    this.frames = (function() {
      var _i, _results;
      _results = [];
      for (i = _i = 0; 0 <= length ? _i < length : _i > length; i = 0 <= length ? ++_i : --_i) {
        data = {};
        data.type = view.getUint8(offset);
        offset += size_Uint8;
        if (data.type) {
          data.morph_index = view.getBySize(offset, model.morph_index_size, true);
          offset += model.morph_index_size;
        } else {
          data.bone_index = view.getBySize(offset, model.bone_index_size, true);
          offset += model.bone_index_size;
        }
        _results.push(data);
      }
      return _results;
    })();
    this.size = offset - _offset;
  }

  return PMXFrame;

})();

PMXRigidBody = (function() {
  function PMXRigidBody(buffer, view, offset, model) {
    var len, _offset;
    _offset = offset;
    len = view.getUint32(offset, true);
    this.name = view.getString(offset + size_Uint32, len, model.utf8Encoding);
    offset += size_Uint32 + size_Uint8 * len;
    len = view.getUint32(offset, true);
    this.english_name = view.getString(offset + size_Uint32, len, model.utf8Encoding);
    offset += size_Uint32 + size_Uint8 * len;
    this.bone_index = view.getBySize(offset, model.bone_index_size, true);
    offset += model.bone_index_size;
    this.group = view.getUint8(offset);
    offset += size_Uint8;
    this.nocollision_group = view.getUint16(offset, true);
    offset += size_Uint16;
    this.figure = view.getUint8(offset);
    offset += size_Uint8;
    this.figure_size = new Float32Array([view.getFloat32(offset, true), view.getFloat32(offset + size_Float32, true), view.getFloat32(offset + size_Float32 * 2, true)]);
    offset += 3 * size_Float32;
    this.position = new Float32Array([view.getFloat32(offset, true), view.getFloat32(offset + size_Float32, true), view.getFloat32(offset + size_Float32 * 2, true)]);
    offset += 3 * size_Float32;
    this.rad = new Float32Array([view.getFloat32(offset, true), view.getFloat32(offset + size_Float32, true), view.getFloat32(offset + size_Float32 * 2, true)]);
    offset += 3 * size_Float32;
    this.mass = view.getFloat32(offset, true);
    offset += size_Float32;
    this.moving_attenuation = view.getFloat32(offset, true);
    offset += size_Float32;
    this.rad_attenuation = view.getFloat32(offset, true);
    offset += size_Float32;
    this.bounce_force = view.getFloat32(offset, true);
    offset += size_Float32;
    this.frictical_force = view.getFloat32(offset, true);
    offset += size_Float32;
    this.mode = view.getUint8(offset);
    offset += size_Uint8;
    this.size = offset - _offset;
  }

  return PMXRigidBody;

})();

PMXJoint = (function() {
  function PMXJoint(buffer, view, offset, model) {
    var len, _offset;
    _offset = offset;
    len = view.getUint32(offset, true);
    this.name = view.getString(offset + size_Uint32, len, model.utf8Encoding);
    offset += size_Uint32 + size_Uint8 * len;
    len = view.getUint32(offset, true);
    this.english_name = view.getString(offset + size_Uint32, len, model.utf8Encoding);
    offset += size_Uint32 + size_Uint8 * len;
    this.type = view.getUint8(offset);
    offset += size_Uint8;
    if (this.type) {
      throw "PMX2.0 not supported";
    }
    this.rigid_index_a = view.getUint8(offset);
    offset += size_Uint8;
    this.rigid_index_b = view.getUint8(offset);
    offset += size_Uint8;
    this.position = new Float32Array([view.getFloat32(offset, true), view.getFloat32(offset + size_Float32, true), view.getFloat32(offset + size_Float32 * 2, true)]);
    offset += 3 * size_Float32;
    this.rad = new Float32Array([view.getFloat32(offset, true), view.getFloat32(offset + size_Float32, true), view.getFloat32(offset + size_Float32 * 2, true)]);
    offset += 3 * size_Float32;
    this.position_lower_vector = new Float32Array([view.getFloat32(offset, true), view.getFloat32(offset + size_Float32, true), view.getFloat32(offset + size_Float32 * 2, true)]);
    offset += 3 * size_Float32;
    this.position_upper_vector = new Float32Array([view.getFloat32(offset, true), view.getFloat32(offset + size_Float32, true), view.getFloat32(offset + size_Float32 * 2, true)]);
    offset += 3 * size_Float32;
    this.rad_lower_vector = new Float32Array([view.getFloat32(offset, true), view.getFloat32(offset + size_Float32, true), view.getFloat32(offset + size_Float32 * 2, true)]);
    offset += 3 * size_Float32;
    this.rad_upper_vector = new Float32Array([view.getFloat32(offset, true), view.getFloat32(offset + size_Float32, true), view.getFloat32(offset + size_Float32 * 2, true)]);
    offset += 3 * size_Float32;
    this.bounce_moving = new Float32Array([view.getFloat32(offset, true), view.getFloat32(offset + size_Float32, true), view.getFloat32(offset + size_Float32 * 2, true)]);
    offset += 3 * size_Float32;
    this.bounce_rad = new Float32Array([view.getFloat32(offset, true), view.getFloat32(offset + size_Float32, true), view.getFloat32(offset + size_Float32 * 2, true)]);
    offset += 3 * size_Float32;
    this.size = offset - _offset;
  }

  return PMXJoint;

})();

this.MMD.PMXRenderer = (function() {
  function PMXRenderer(mmd, model) {
    this.mmd = mmd;
    this.model = model;
    this.gl = this.mmd.gl;
    this.vbuffers = {};
    this.initVertices();
    this.initIndices();
    this.initTextures();
    this.initMatrices();
    this.motions = {};
    this.playing = false;
    this.frame = -1;
    return;
  }

  PMXRenderer.prototype.initVertices = function() {
    var bone1, bone2, bone3, bone4, buffer, data, i, length, model, morphVec, normals, positions, positions1, positions2, positions3, positions4, rotations1, rotations2, rotations3, rotations4, sdefC, sdefR0, sdefR1, uvs, vectors1, vectors2, vectors3, vectors4, vertex, weightTypes, weights, _i, _j, _len, _ref;
    model = this.model;
    length = model.vertices.length;
    weightTypes = new Float32Array(length);
    weights = new Float32Array(length * 4);
    vectors1 = new Float32Array(length * 3);
    vectors2 = new Float32Array(length * 3);
    vectors3 = new Float32Array(length * 3);
    vectors4 = new Float32Array(length * 3);
    positions1 = new Float32Array(length * 3);
    positions2 = new Float32Array(length * 3);
    positions3 = new Float32Array(length * 3);
    positions4 = new Float32Array(length * 3);
    rotations1 = new Float32Array(length * 4);
    rotations2 = new Float32Array(length * 4);
    rotations3 = new Float32Array(length * 4);
    rotations4 = new Float32Array(length * 4);
    morphVec = new Float32Array(3 * length);
    sdefC = new Float32Array(length * 3);
    sdefR0 = new Float32Array(length * 3);
    sdefR1 = new Float32Array(length * 3);
    positions = new Float32Array(length * 3);
    normals = new Float32Array(length * 3);
    uvs = new Float32Array(length * 2);
    for (i = _i = 0; 0 <= length ? _i < length : _i > length; i = 0 <= length ? ++_i : --_i) {
      vertex = model.vertices[i];
      weightTypes[i] = vertex.weight_type;
      if (vertex.weight_type >= 0) {
        bone1 = model.bones[vertex.bone_num1];
        rotations1[4 * i + 3] = 1;
        vectors1[3 * i] = vertex.x - bone1.head_pos[0];
        vectors1[3 * i + 1] = vertex.y - bone1.head_pos[1];
        vectors1[3 * i + 2] = vertex.z - bone1.head_pos[2];
        positions1[3 * i] = bone1.head_pos[0];
        positions1[3 * i + 1] = bone1.head_pos[1];
        positions1[3 * i + 2] = bone1.head_pos[2];
        weights[4 * i] = 1;
      }
      if (vertex.weight_type >= 1) {
        bone2 = model.bones[vertex.bone_num2];
        rotations2[4 * i + 3] = 1;
        vectors2[3 * i] = vertex.x - bone2.head_pos[0];
        vectors2[3 * i + 1] = vertex.y - bone2.head_pos[1];
        vectors2[3 * i + 2] = vertex.z - bone2.head_pos[2];
        positions2[3 * i] = bone2.head_pos[0];
        positions2[3 * i + 1] = bone2.head_pos[1];
        positions2[3 * i + 2] = bone2.head_pos[2];
        weights[4 * i] = vertex.bone_weight1;
        weights[4 * i + 1] = 1 - vertex.bone_weight1;
      }
      if (vertex.weight_type === 2) {
        bone3 = model.bones[vertex.bone_num3];
        bone4 = model.bones[vertex.bone_num4];
        rotations3[4 * i + 3] = 1;
        rotations4[4 * i + 3] = 1;
        vectors3[3 * i] = vertex.x - bone3.head_pos[0];
        vectors3[3 * i + 1] = vertex.y - bone3.head_pos[1];
        vectors3[3 * i + 2] = vertex.z - bone3.head_pos[2];
        vectors4[3 * i] = vertex.x - bone4.head_pos[0];
        vectors4[3 * i + 1] = vertex.y - bone4.head_pos[1];
        vectors4[3 * i + 2] = vertex.z - bone4.head_pos[2];
        positions3[3 * i] = bone3.head_pos[0];
        positions3[3 * i + 1] = bone3.head_pos[1];
        positions3[3 * i + 2] = bone3.head_pos[2];
        positions4[3 * i] = bone4.head_pos[0];
        positions4[3 * i + 1] = bone4.head_pos[1];
        positions4[3 * i + 2] = bone4.head_pos[2];
        weights[4 * i] = vertex.bone_weight1;
        weights[4 * i + 1] = vertex.bone_weight2;
        weights[4 * i + 2] = vertex.bone_weight3;
        weights[4 * i + 3] = vertex.bone_weight4;
      }
      if (vertex.weight_type === 3) {
        sdefC[3 * i] = vertex.C[0];
        sdefC[3 * i + 1] = vertex.C[1];
        sdefC[3 * i + 2] = vertex.C[2];
        sdefR0[3 * i] = vertex.R0[0];
        sdefR0[3 * i + 1] = vertex.R0[1];
        sdefR0[3 * i + 2] = vertex.R0[2];
        sdefR1[3 * i] = vertex.R1[0];
        sdefR1[3 * i + 1] = vertex.R1[1];
        sdefR1[3 * i + 2] = vertex.R1[2];
      }
      positions[3 * i] = vertex.x;
      positions[3 * i + 1] = vertex.y;
      positions[3 * i + 2] = vertex.z;
      normals[3 * i] = vertex.nx;
      normals[3 * i + 1] = vertex.ny;
      normals[3 * i + 2] = vertex.nz;
      uvs[2 * i] = vertex.u;
      uvs[2 * i + 1] = vertex.v;
    }
    model.rotations1 = rotations1;
    model.rotations2 = rotations2;
    model.rotations3 = rotations3;
    model.rotations4 = rotations4;
    model.positions1 = positions1;
    model.positions2 = positions2;
    model.positions3 = positions3;
    model.positions4 = positions4;
    model.morphVec = morphVec;
    _ref = [
      {
        attribute: 'aWeightType',
        array: weightTypes,
        size: 1
      }, {
        attribute: 'aBoneWeights',
        array: weights,
        size: 4
      }, {
        attribute: 'aVectorFromBone1',
        array: vectors1,
        size: 3
      }, {
        attribute: 'aVectorFromBone2',
        array: vectors2,
        size: 3
      }, {
        attribute: 'aVectorFromBone3',
        array: vectors3,
        size: 3
      }, {
        attribute: 'aVectorFromBone4',
        array: vectors4,
        size: 3
      }, {
        attribute: 'aBone1Position',
        array: positions1,
        size: 3
      }, {
        attribute: 'aBone2Position',
        array: positions2,
        size: 3
      }, {
        attribute: 'aBone3Position',
        array: positions3,
        size: 3
      }, {
        attribute: 'aBone4Position',
        array: positions4,
        size: 3
      }, {
        attribute: 'aBone1Rotation',
        array: rotations1,
        size: 4
      }, {
        attribute: 'aBone2Rotation',
        array: rotations2,
        size: 4
      }, {
        attribute: 'aBone3Rotation',
        array: rotations3,
        size: 4
      }, {
        attribute: 'aBone4Rotation',
        array: rotations4,
        size: 4
      }, {
        attribute: 'aVertexNormal',
        array: normals,
        size: 3
      }, {
        attribute: 'aTextureCoord',
        array: uvs,
        size: 2
      }
    ];
    for (_j = 0, _len = _ref.length; _j < _len; _j++) {
      data = _ref[_j];
      buffer = this.gl.createBuffer();
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, buffer);
      this.gl.bufferData(this.gl.ARRAY_BUFFER, data.array, this.gl.STATIC_DRAW);
      this.vbuffers[data.attribute] = {
        size: data.size,
        buffer: buffer
      };
    }
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);
  };

  PMXRenderer.prototype.initIndices = function() {
    var indices;
    indices = this.model.triangles;
    this.ibuffer = this.gl.createBuffer();
    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.ibuffer);
    this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, indices, this.gl.STATIC_DRAW);
    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, null);
  };

  PMXRenderer.prototype.initTextures = function() {
    var fileName, material, model, toonFlag, toonIndex, type, _i, _j, _len, _len1, _ref, _ref1;
    model = this.model;
    this.textureManager = new MMD.TextureManager(this.mmd);
    this.textureManager.onload = (function(_this) {
      return function() {
        return _this.redraw = true;
      };
    })(this);
    _ref = model.materials;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      material = _ref[_i];
      if (!material.textures) {
        material.textures = {};
      }
      toonFlag = material.toon_flag;
      toonIndex = material.toon_index;
      if (toonFlag === 1) {
        fileName = 'toon' + ('0' + (toonIndex + 1)).slice(-2) + '.bmp';
        if (toonIndex === -1 || !model.toon_file_names || fileName === model.toon_file_names[toonIndex]) {
          fileName = 'data/' + fileName;
        } else {
          fileName = model.directory + '/' + model.toon_file_names[toonIndex];
        }
        material.textures.toon = this.textureManager.get('toon', fileName);
      } else if (toonFlag === 0 && toonIndex >= 0) {
        fileName = model.textures[toonIndex];
        material.textures.toon = this.textureManager.get('toon', model.directory + '/' + fileName);
      }
      if (material.texture_file_name) {
        _ref1 = material.texture_file_name.split('*');
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          fileName = _ref1[_j];
          switch (fileName.slice(-4)) {
            case '.sph':
              type = 'sph';
              break;
            case '.spa':
              type = 'spa';
              break;
            case '.tga':
              type = 'regular';
              fileName += '.png';
              break;
            default:
              type = 'regular';
          }
          material.textures[type] = this.textureManager.get(type, model.directory + '/' + fileName);
        }
      }
    }
  };

  PMXRenderer.prototype.render = function() {
    var attribute, material, offset, vb, _i, _j, _len, _len1, _ref, _ref1, _ref2;
    this.mmd.setPMXUniforms();
    this.program = this.mmd.pmxProgram;
    _ref = this.vbuffers;
    for (attribute in _ref) {
      vb = _ref[attribute];
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, vb.buffer);
      this.gl.vertexAttribPointer(this.program[attribute], vb.size, this.gl.FLOAT, false, 0, 0);
    }
    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.ibuffer);
    this.gl.enable(this.gl.CULL_FACE);
    this.gl.enable(this.gl.BLEND);
    this.gl.blendFuncSeparate(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA, this.gl.SRC_ALPHA, this.gl.DST_ALPHA);
    offset = 0;
    _ref1 = this.model.materials;
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      material = _ref1[_i];
      this.renderMaterial(material, offset);
      offset += material.face_vert_count;
    }
    this.gl.disable(this.gl.BLEND);
    offset = 0;
    _ref2 = this.model.materials;
    for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
      material = _ref2[_j];
      this.renderEdge(material, offset);
      offset += material.face_vert_count;
    }
  };

  PMXRenderer.prototype.renderMaterial = function(material, offset) {
    var length, textures;
    this.gl.uniform3fv(this.program.uAmbientColor, material.ambient);
    this.gl.uniform3fv(this.program.uSpecularColor, material.specular);
    this.gl.uniform3fv(this.program.uDiffuseColor, material.diffuse);
    this.gl.uniform1f(this.program.uAlpha, material.alpha);
    this.gl.uniform1f(this.program.uShininess, material.shininess);
    textures = material.textures;
    this.gl.activeTexture(this.gl.TEXTURE0);
    this.gl.bindTexture(this.gl.TEXTURE_2D, textures.toon);
    this.gl.uniform1i(this.program.uToon, 0);
    if (textures.regular) {
      this.gl.activeTexture(this.gl.TEXTURE1);
      this.gl.bindTexture(this.gl.TEXTURE_2D, textures.regular);
      this.gl.uniform1i(this.program.uTexture, 1);
    }
    this.gl.uniform1i(this.program.uUseTexture, !!textures.regular);
    if (textures.sph || textures.spa) {
      this.gl.activeTexture(this.gl.TEXTURE2);
      this.gl.bindTexture(this.gl.TEXTURE_2D, textures.sph || textures.spa);
      this.gl.uniform1i(this.program.uSphereMap, 2);
      this.gl.uniform1i(this.program.uUseSphereMap, true);
      this.gl.uniform1i(this.program.uIsSphereMapAdditive, !!textures.spa);
    } else {
      this.gl.uniform1i(this.program.uUseSphereMap, false);
    }
    length = material.face_vert_count;
    switch (this.model.vertex_index_size) {
      case 1:
        this.gl.drawElements(this.gl.TRIANGLES, length, this.gl.UNSIGNED_BYTE, offset);
        break;
      case 2:
        this.gl.drawElements(this.gl.TRIANGLES, length, this.gl.UNSIGNED_SHORT, offset * 2);
        break;
      case 4:
        this.gl.drawElements(this.gl.TRIANGLES, length, this.gl.UNSIGNED_INT, offset * 4);
        break;
      default:
        console.log("vertex index size not found " + this.model.vertex_index_size);
    }
  };

  PMXRenderer.prototype.renderEdge = function(material, offset) {};

  PMXRenderer.prototype.move = function() {
    if (!this.playing || !this.motionManager) {
      return;
    }
    if (++this.frame > this.motionManager.lastFrame) {
      this.frame = -1;
      this.playing = false;
      return;
    }
    this.moveModel();
  };

  PMXRenderer.prototype.moveModel = function() {
    var bones, morphs, _ref;
    _ref = this.motionManager.getModelFrame(this.model, this.frame), morphs = _ref.morphs, bones = _ref.bones;
    this.moveMorphs(this.model, morphs);
    this.moveBones(this.model, bones);
  };

  PMXRenderer.prototype.moveMorphs = function(model, morphs) {
    if (!morphs) {
      return;
    }
    if (model.morphs.length === 0) {
      return;
    }
  };

  PMXRenderer.prototype.moveBones = function(model, bones) {
    var bone, boneMotions, constrainedBones, getBoneMotion, i, individualBoneMotions, length, motion1, motion2, motion3, motion4, originalBonePositions, parentBones, pos1, pos2, pos3, pos4, positions1, positions2, positions3, positions4, resolveIKs, rot1, rot2, rot3, rot4, rotations1, rotations2, rotations3, rotations4, vertex, _i, _j, _k, _len, _ref, _ref1, _ref2;
    if (!bones) {
      return;
    }
    individualBoneMotions = [];
    boneMotions = [];
    originalBonePositions = [];
    parentBones = [];
    constrainedBones = [];
    _ref = model.bones;
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      bone = _ref[i];
      individualBoneMotions[i] = (_ref1 = bones[bone.name]) != null ? _ref1 : {
        rotation: quat4.create([0, 0, 0, 1]),
        location: vec3.create()
      };
      boneMotions[i] = {
        r: quat4.create(),
        p: vec3.create(),
        tainted: true
      };
      originalBonePositions[i] = bone.head_pos;
      parentBones[i] = bone.parent_bone_index;
      if (bone.name.indexOf('\u3072\u3056') > 0) {
        constrainedBones[i] = true;
      }
      if (bone.ik_flag && bone.ik_rad_limited) {
        constrainedBones[i] = true;
      }
    }
    getBoneMotion = function(boneIndex) {
      var m, motion, p, parentIndex, parentMotion, r, t;
      motion = boneMotions[boneIndex];
      if (motion && !motion.tainted) {
        return motion;
      }
      m = individualBoneMotions[boneIndex];
      r = quat4.set(m.rotation, motion.r);
      t = m.location;
      p = vec3.set(originalBonePositions[boneIndex], motion.p);
      if (parentBones[boneIndex] === -1) {
        return boneMotions[boneIndex] = {
          p: vec3.add(p, t),
          r: r,
          tainted: false
        };
      } else {
        parentIndex = parentBones[boneIndex];
        parentMotion = getBoneMotion(parentIndex);
        r = quat4.multiply(parentMotion.r, r, r);
        p = vec3.subtract(p, originalBonePositions[parentIndex]);
        vec3.add(p, t);
        vec3.rotateByQuat4(p, parentMotion.r);
        vec3.add(p, parentMotion.p);
        return boneMotions[boneIndex] = {
          p: p,
          r: r,
          tainted: false
        };
      }
    };
    resolveIKs = function() {
      var axis, axisLen, boneIndex, bonePos, bone_index, c, child_bone, ik, ikbonePos, ikboneVec, ikboneVecLen, j, minLength, motion, n, parentRotation, q, r, sinTheta, targetIndex, targetPos, targetVec, targetVecLen, theta, tmpQ, tmpR, _j, _len1, _ref2, _results;
      targetVec = vec3.create();
      ikboneVec = vec3.create();
      axis = vec3.create();
      tmpQ = quat4.create();
      tmpR = quat4.create();
      _ref2 = model.bones;
      _results = [];
      for (bone_index = _j = 0, _len1 = _ref2.length; _j < _len1; bone_index = ++_j) {
        bone = _ref2[bone_index];
        if (bone.ik_flag == null) {
          continue;
        }
        ik = bone;
        ikbonePos = getBoneMotion(bone_index).p;
        targetIndex = ik.target_bone_index;
        minLength = 0.1 * vec3.length(vec3.subtract(originalBonePositions[targetIndex], originalBonePositions[parentBones[targetIndex]], axis));
        _results.push((function() {
          var _k, _ref3, _results1;
          _results1 = [];
          for (n = _k = 0, _ref3 = ik.iterations; 0 <= _ref3 ? _k < _ref3 : _k > _ref3; n = 0 <= _ref3 ? ++_k : --_k) {
            targetPos = getBoneMotion(targetIndex).p;
            if (minLength > vec3.length(vec3.subtract(targetPos, ikbonePos, axis))) {
              break;
            }
            _results1.push((function() {
              var _l, _len2, _m, _ref4, _results2;
              _ref4 = ik.child_bones;
              _results2 = [];
              for (i = _l = 0, _len2 = _ref4.length; _l < _len2; i = ++_l) {
                child_bone = _ref4[i];
                boneIndex = child_bone.link_index;
                motion = getBoneMotion(boneIndex);
                bonePos = motion.p;
                if (i > 0) {
                  targetPos = getBoneMotion(targetIndex).p;
                }
                targetVec = vec3.subtract(targetPos, bonePos, targetVec);
                targetVecLen = vec3.length(targetVec);
                if (targetVecLen < minLength) {
                  continue;
                }
                ikboneVec = vec3.subtract(ikbonePos, bonePos, ikboneVec);
                ikboneVecLen = vec3.length(ikboneVec);
                if (ikboneVecLen < minLength) {
                  continue;
                }
                axis = vec3.cross(targetVec, ikboneVec, axis);
                axisLen = vec3.length(axis);
                sinTheta = axisLen / ikboneVecLen / targetVecLen;
                if (sinTheta < 0.001) {
                  continue;
                }
                theta = Math.asin(sinTheta);
                if (vec3.dot(targetVec, ikboneVec) < 0) {
                  theta = 3.141592653589793 - theta;
                }
                q = quat4.set(vec3.scale(axis, Math.sin(theta / 2) / axisLen), tmpQ);
                q[3] = Math.cos(theta / 2);
                parentRotation = getBoneMotion(parentBones[boneIndex]).r;
                r = quat4.inverse(parentRotation, tmpR);
                r = quat4.multiply(quat4.multiply(r, q), motion.r);
                if (constrainedBones[boneIndex]) {
                  c = r[3];
                  r = quat4.set([Math.sqrt(1 - c * c), 0, 0, c], r);
                  quat4.inverse(boneMotions[boneIndex].r, q);
                  quat4.multiply(r, q, q);
                  q = quat4.multiply(parentRotation, q, q);
                }
                quat4.normalize(r, individualBoneMotions[boneIndex].rotation);
                quat4.multiply(q, motion.r, motion.r);
                for (j = _m = 0; 0 <= i ? _m < i : _m > i; j = 0 <= i ? ++_m : --_m) {
                  boneMotions[ik.child_bones[j].link_index].tainted = true;
                }
                _results2.push(boneMotions[ik.target_bone_index].tainted = true);
              }
              return _results2;
            })());
          }
          return _results1;
        })());
      }
      return _results;
    };
    resolveIKs();
    for (i = _j = 0, _ref2 = model.bones.length; 0 <= _ref2 ? _j < _ref2 : _j > _ref2; i = 0 <= _ref2 ? ++_j : --_j) {
      getBoneMotion(i);
    }
    rotations1 = model.rotations1;
    rotations2 = model.rotations2;
    rotations3 = model.rotations3;
    rotations4 = model.rotations4;
    positions1 = model.positions1;
    positions2 = model.positions2;
    positions3 = model.positions3;
    positions4 = model.positions4;
    length = model.vertices.length;
    for (i = _k = 0; 0 <= length ? _k < length : _k > length; i = 0 <= length ? ++_k : --_k) {
      vertex = model.vertices[i];
      if (vertex.weight_type >= 0) {
        motion1 = boneMotions[vertex.bone_num1];
        rot1 = motion1.r;
        pos1 = motion1.p;
        rotations1[i * 4] = rot1[0];
        rotations1[i * 4 + 1] = rot1[1];
        rotations1[i * 4 + 2] = rot1[2];
        rotations1[i * 4 + 3] = rot1[3];
        positions1[i * 3] = pos1[0];
        positions1[i * 3 + 1] = pos1[1];
        positions1[i * 3 + 2] = pos1[2];
      }
      if (vertex.weight_type >= 1) {
        motion2 = boneMotions[vertex.bone_num2];
        rot2 = motion2.r;
        pos2 = motion2.p;
        rotations2[i * 4] = rot2[0];
        rotations2[i * 4 + 1] = rot2[1];
        rotations2[i * 4 + 2] = rot2[2];
        rotations2[i * 4 + 3] = rot2[3];
        positions2[i * 3] = pos2[0];
        positions2[i * 3 + 1] = pos2[1];
        positions2[i * 3 + 2] = pos2[2];
      }
      if (vertex.weight_type === 2) {
        motion3 = boneMotions[vertex.bone_num3];
        motion4 = boneMotions[vertex.bone_num4];
        rot3 = motion3.r;
        pos3 = motion3.p;
        rotations3[i * 4] = rot3[0];
        rotations3[i * 4 + 1] = rot3[1];
        rotations3[i * 4 + 2] = rot3[2];
        rotations3[i * 4 + 3] = rot3[3];
        positions3[i * 3] = pos3[0];
        positions3[i * 3 + 1] = pos3[1];
        positions3[i * 3 + 2] = pos3[2];
        rot4 = motion4.r;
        pos4 = motion4.p;
        rotations4[i * 4] = rot4[0];
        rotations4[i * 4 + 1] = rot4[1];
        rotations4[i * 4 + 2] = rot4[2];
        rotations4[i * 4 + 3] = rot4[3];
        positions4[i * 3] = pos4[0];
        positions4[i * 3 + 1] = pos4[1];
        positions4[i * 3 + 2] = pos4[2];
      }
      if (vertex.weight_type === 4) {
        null;
      }
    }
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vbuffers.aBone1Rotation.buffer);
    this.gl.bufferData(this.gl.ARRAY_BUFFER, rotations1, this.gl.STATIC_DRAW);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vbuffers.aBone2Rotation.buffer);
    this.gl.bufferData(this.gl.ARRAY_BUFFER, rotations2, this.gl.STATIC_DRAW);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vbuffers.aBone3Rotation.buffer);
    this.gl.bufferData(this.gl.ARRAY_BUFFER, rotations3, this.gl.STATIC_DRAW);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vbuffers.aBone4Rotation.buffer);
    this.gl.bufferData(this.gl.ARRAY_BUFFER, rotations4, this.gl.STATIC_DRAW);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vbuffers.aBone1Position.buffer);
    this.gl.bufferData(this.gl.ARRAY_BUFFER, positions1, this.gl.STATIC_DRAW);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vbuffers.aBone2Position.buffer);
    this.gl.bufferData(this.gl.ARRAY_BUFFER, positions2, this.gl.STATIC_DRAW);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vbuffers.aBone3Position.buffer);
    this.gl.bufferData(this.gl.ARRAY_BUFFER, positions3, this.gl.STATIC_DRAW);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vbuffers.aBone4Position.buffer);
    this.gl.bufferData(this.gl.ARRAY_BUFFER, positions4, this.gl.STATIC_DRAW);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);
  };

  PMXRenderer.prototype.initMatrices = function() {
    return this.modelMatrix = mat4.createIdentity();
  };

  PMXRenderer.prototype.translate = function(x, y, z) {
    return mat4.translate(this.modelMatrix, [x, y, z]);
  };

  PMXRenderer.prototype.scale = function(x, y, z) {
    return mat4.scale(this.modelMatrix, [x, y, z]);
  };

  PMXRenderer.prototype.rotate = function(angle, x, y, z) {
    return mat4.rotate(this.modelMatrix, angle, [x, y, z]);
  };

  PMXRenderer.prototype.addModelMotion = function(motionName, motion, merge_flag, frame_offset) {
    var motionManager;
    motionManager = new MMD.MotionManager;
    motionManager.addModelMotion(this.model, motion, merge_flag, frame_offset);
    return this.motions[motionName] = motionManager;
  };

  PMXRenderer.prototype.play = function(motionName) {
    this.playing = true;
    this.motionManager = this.motions[motionName];
    if (!this.motionManager) {
      console.log("" + motionName + " not found in the motions");
    }
    return this.frame = -1;
  };

  return PMXRenderer;

})();

MMD.PMDVertexShaderSource = '\nuniform mat4 uMVMatrix; // model-view matrix (model -> view space)\nuniform mat4 uPMatrix; // projection matrix (view -> projection space)\nuniform mat4 uNMatrix; // normal matrix (inverse of transpose of model-view matrix)\n\nuniform mat4 uLightMatrix; // mvpdMatrix of light space (model -> display space)\n\nattribute vec3 aVertexNormal;\nattribute vec2 aTextureCoord;\nattribute float aVertexEdge; // 0 or 1. 1 if the vertex has an edge. (becuase we can\'t pass bool to attributes)\n\nattribute float aBoneWeight;\nattribute vec3 aVectorFromBone1;\nattribute vec3 aVectorFromBone2;\nattribute vec4 aBone1Rotation;\nattribute vec4 aBone2Rotation;\nattribute vec3 aBone1Position;\nattribute vec3 aBone2Position;\n\nattribute vec3 aMultiPurposeVector;\n\nvarying vec3 vPosition;\nvarying vec3 vNormal;\nvarying vec2 vTextureCoord;\nvarying vec4 vLightCoord; // coordinate in light space; to be mapped onto shadow map\n\nuniform float uEdgeThickness;\nuniform bool uEdge;\n\nuniform bool uGenerateShadowMap;\n\nuniform bool uSelfShadow;\n\nuniform bool uAxis;\nuniform bool uCenterPoint;\n\nvec3 qtransform(vec4 q, vec3 v) {\n  return v + 2.0 * cross(cross(v, q.xyz) - q.w*v, q.xyz);\n}\n\nvoid main() {\n  vec3 position;\n  vec3 normal;\n\n  if (uAxis || uCenterPoint) {\n\n    position = aMultiPurposeVector;\n\n  } else {\n\n    float weight = aBoneWeight;\n    vec3 morph = aMultiPurposeVector;\n\n    position = qtransform(aBone1Rotation, aVectorFromBone1 + morph) + aBone1Position;\n    normal = qtransform(aBone1Rotation, aVertexNormal);\n\n    if (weight < 0.99) {\n      vec3 p2 = qtransform(aBone2Rotation, aVectorFromBone2 + morph) + aBone2Position;\n      vec3 n2 = qtransform(aBone2Rotation, normal);\n\n      position = mix(p2, position, weight);\n      normal = normalize(mix(n2, normal, weight));\n    }\n  }\n\n  // return vertex point in projection space\n  gl_Position = uPMatrix * uMVMatrix * vec4(position, 1.0);\n\n  if (uCenterPoint) {\n    gl_Position.z = 0.0; // always on top\n    gl_PointSize = 16.0;\n  }\n\n  if (uGenerateShadowMap || uAxis || uCenterPoint) return;\n\n  // for fragment shader\n  vTextureCoord = aTextureCoord;\n  vPosition = (uMVMatrix * vec4(position, 1.0)).xyz;\n  vNormal = (uNMatrix * vec4(normal, 1.0)).xyz;\n\n  if (uSelfShadow) {\n    vLightCoord = uLightMatrix * vec4(position, 1.0);\n  }\n\n  if (uEdge) {\n    vec4 pos = gl_Position;\n    vec4 pos2 = uPMatrix * uMVMatrix * vec4(position + normal, 1.0);\n    vec4 norm = normalize(pos2 - pos);\n    gl_Position = pos + norm * uEdgeThickness * aVertexEdge * pos.w; // scale by pos.w to prevent becoming thicker when zoomed\n    return;\n  }\n}\n';

MMD.PMDFragmentShaderSource = '\n#ifdef GL_ES\nprecision highp float;\n#endif\n\nvarying vec2 vTextureCoord;\nvarying vec3 vPosition;\nvarying vec3 vNormal;\nvarying vec4 vLightCoord;\n\nuniform vec3 uLightDirection; // light source direction in world space\nuniform vec3 uLightColor;\n\nuniform vec3 uAmbientColor;\nuniform vec3 uSpecularColor;\nuniform vec3 uDiffuseColor;\nuniform float uAlpha;\nuniform float uShininess;\n\nuniform bool uUseTexture;\nuniform bool uUseSphereMap;\nuniform bool uIsSphereMapAdditive;\n\nuniform sampler2D uToon;\nuniform sampler2D uTexture;\nuniform sampler2D uSphereMap;\n\nuniform bool uEdge;\nuniform float uEdgeThickness;\nuniform vec3 uEdgeColor;\n\nuniform bool uGenerateShadowMap;\nuniform bool uSelfShadow;\nuniform sampler2D uShadowMap;\n\nuniform bool uAxis;\nuniform vec3 uAxisColor;\nuniform bool uCenterPoint;\n\n// from http://spidergl.org/example.php?id=6\nvec4 pack_depth(const in float depth) {\n  const vec4 bit_shift = vec4(256.0*256.0*256.0, 256.0*256.0, 256.0, 1.0);\n  const vec4 bit_mask  = vec4(0.0, 1.0/256.0, 1.0/256.0, 1.0/256.0);\n  vec4 res = fract(depth * bit_shift);\n  res -= res.xxyz * bit_mask;\n  return res;\n}\nfloat unpack_depth(const in vec4 rgba_depth)\n{\n  const vec4 bit_shift = vec4(1.0/(256.0*256.0*256.0), 1.0/(256.0*256.0), 1.0/256.0, 1.0);\n  float depth = dot(rgba_depth, bit_shift);\n  return depth;\n}\n\nvoid main() {\n  if (uGenerateShadowMap) {\n    //gl_FragData[0] = pack_depth(gl_FragCoord.z);\n    gl_FragColor = pack_depth(gl_FragCoord.z);\n    return;\n  }\n  if (uAxis) {\n    gl_FragColor = vec4(uAxisColor, 1.0);\n    return;\n  }\n  if (uCenterPoint) {\n    vec2 uv = gl_PointCoord * 2.0 - 1.0; // transform [0, 1] -> [-1, 1] coord systems\n    float w = dot(uv, uv);\n    if (w < 0.3 || (w > 0.5 && w < 1.0)) {\n      gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n    } else {\n      discard;\n    }\n    return;\n  }\n\n  // vectors are in view space\n  vec3 norm = normalize(vNormal); // each point\'s normal vector in view space\n  vec3 cameraDirection = normalize(-vPosition); // camera located at origin in view space\n\n  vec3 color;\n  float alpha = uAlpha;\n\n  if (uEdge) {\n\n    color = uEdgeColor;\n\n  } else {\n\n    color = vec3(1.0, 1.0, 1.0);\n    if (uUseTexture) {\n      vec4 texColor = texture2D(uTexture, vTextureCoord);\n      color *= texColor.rgb;\n      alpha *= texColor.a;\n    }\n    if (uUseSphereMap) {\n      vec2 sphereCoord = 0.5 * (1.0 + vec2(1.0, -1.0) * norm.xy);\n      if (uIsSphereMapAdditive) {\n        color += texture2D(uSphereMap, sphereCoord).rgb;\n      } else {\n        color *= texture2D(uSphereMap, sphereCoord).rgb;\n      }\n    }\n\n    // specular component\n    vec3 halfAngle = normalize(uLightDirection + cameraDirection);\n    float specularWeight = pow( max(0.001, dot(halfAngle, norm)) , uShininess );\n    //float specularWeight = pow( max(0.0, dot(reflect(-uLightDirection, norm), cameraDirection)) , uShininess ); // another definition\n    vec3 specular = specularWeight * uSpecularColor;\n\n    vec2 toonCoord = vec2(0.0, 0.5 * (1.0 - dot( uLightDirection, norm )));\n\n    if (uSelfShadow) {\n      vec3 lightCoord = vLightCoord.xyz / vLightCoord.w; // projection to texture coordinate (in light space)\n      vec4 rgbaDepth = texture2D(uShadowMap, lightCoord.xy);\n      float depth = unpack_depth(rgbaDepth);\n      if (depth < lightCoord.z - 0.01) {\n        toonCoord = vec2(0.0, 0.55);\n      }\n    }\n\n    color *= uAmbientColor + uLightColor * (uDiffuseColor + specular);\n\n    color = clamp(color, 0.0, 1.0);\n    color *= texture2D(uToon, toonCoord).rgb;\n\n  }\n  gl_FragColor = vec4(color, alpha);\n\n}\n';

MMD.PMXVertexShaderSource = '\nprecision mediump float;\n\nuniform mat4 uMVMatrix; // model-view matrix (model -> view space)\nuniform mat4 uPMatrix; // projection matrix (view -> projection space)\nuniform mat4 uNMatrix; // normal matrix (inverse of transpose of model-view matrix)\n\n// attribute vec3 aVertexPosition;\nattribute vec3 aVertexNormal;\nattribute vec2 aTextureCoord;\n\n// for vertices\nattribute float aWeightType;   // 0=BDEF1 1=BDEF2 2=BDEF4 3=SDEF\nattribute vec4 aBoneWeights;\n// remove all aVectorFromBoneX due to the limit of VertexShader attributes\nattribute vec3 aVectorFromBone1;\nattribute vec3 aVectorFromBone2;\nattribute vec3 aVectorFromBone3;\nattribute vec3 aVectorFromBone4;\n\nattribute vec3 aBone1Position;\nattribute vec3 aBone2Position;\nattribute vec3 aBone3Position;\nattribute vec3 aBone4Position;\nattribute vec4 aBone1Rotation;\nattribute vec4 aBone2Rotation;\nattribute vec4 aBone3Rotation;\nattribute vec4 aBone4Rotation;\n// attribute vec3 aMultiPurposeVector;\n\nvarying vec2 vTextureCoord;\nvarying vec3 vPosition;\nvarying vec3 vNormal;\n\nvec3 qtransform(vec4 q, vec3 v) {\n  return v + 2.0 * cross(cross(v, q.xyz) - q.w*v, q.xyz);\n}\n\nvoid main() {\n  vec3 position;\n  vec3 normal = aVertexNormal;\n  // vec3 morph = aMultiPurposeVector;\n  vec3 morph = vec3(0, 0, 0);\n\n  // // calculate vector from bones\n  // vec3 vectorFromBone1 = aVertexPosition - aBone1Position;\n  // vec3 vectorFromBone2 = aVertexPosition - aBone2Position;\n  // vec3 vectorFromBone3 = aVertexPosition - aBone3Position;\n  // vec3 vectorFromBone4 = aVertexPosition - aBone4Position;\n\n  // check type of deformation\n  int type = int(aWeightType);\n  if (type == 0)            // BDEF1\n  {\n    position = qtransform(aBone1Rotation, aVectorFromBone1 + morph) + aBone1Position;\n  }\n  else if (type == 1)       // BDEF2\n  {\n    vec3 p1 = qtransform(aBone1Rotation, aVectorFromBone1 + morph) + aBone1Position;\n    vec3 p2 = qtransform(aBone2Rotation, aVectorFromBone2 + morph) + aBone2Position;\n    position = mix(p2, p1, aBoneWeights[0]);\n  }\n  else if (type == 2)       // BDEF 4\n  {\n    vec3 p1 = qtransform(aBone1Rotation, aVectorFromBone1 + morph) + aBone1Position;\n    vec3 p2 = qtransform(aBone2Rotation, aVectorFromBone2 + morph) + aBone2Position;\n    vec3 p3 = qtransform(aBone3Rotation, aVectorFromBone3 + morph) + aBone3Position;\n    vec3 p4 = qtransform(aBone4Rotation, aVectorFromBone4 + morph) + aBone4Position;\n    position = p1 * aBoneWeights[0] + p2 * aBoneWeights[1] + p3 * aBoneWeights[2] + p4 * aBoneWeights[3];\n  }\n  else                      // SDEF \n  {\n    // not implemented\n    vec3 p1 = qtransform(aBone1Rotation, aVectorFromBone1 + morph) + aBone1Position;\n    vec3 p2 = qtransform(aBone2Rotation, aVectorFromBone2 + morph) + aBone2Position;\n    position = mix(p2, p1, aBoneWeights[0]);\n  }\n\n  gl_Position = uPMatrix * uMVMatrix * vec4(position, 1.0);\n\n  // for fragment shader\n  vTextureCoord = aTextureCoord;\n  vPosition = (uMVMatrix * vec4(position, 1.0)).xyz;\n  // vPosition = (uMVMatrix * vec4(aVertexPosition, 1.0)).xyz;\n  vNormal = (uNMatrix * vec4(normal, 1.0)).xyz;\n}\n';

MMD.PMXFragmentShaderSource = '\nprecision mediump float;\n \nvarying vec2 vTextureCoord;\nvarying vec3 vPosition;\nvarying vec3 vNormal;\n// varying vec4 vLightCoord;\n\nuniform vec3 uLightDirection; // light source direction in world space\nuniform vec3 uLightColor;\n\nuniform vec3 uAmbientColor;\nuniform vec3 uSpecularColor;\nuniform vec3 uDiffuseColor;\nuniform float uAlpha;\nuniform float uShininess;\n\nuniform bool uUseTexture;\nuniform bool uUseSphereMap;\nuniform bool uIsSphereMapAdditive;\n\nuniform sampler2D uToon;\nuniform sampler2D uTexture;\nuniform sampler2D uSphereMap;\n\nvoid main() {\n  vec3 color;\n  float alpha = uAlpha;\n\n  // vectors are in view space\n  vec3 norm = normalize(vNormal); // each point\'s normal vector in view space\n  vec3 cameraDirection = normalize(-vPosition); // camera located at origin in view space\n\n  color = vec3(1.0, 1.0, 1.0);\n  if (uUseTexture) {\n    vec4 texColor = texture2D(uTexture, vTextureCoord);\n    color *= texColor.rgb;\n    alpha *= texColor.a;\n  }\n\n  if (uUseSphereMap) {\n    vec2 sphereCoord = 0.5 * (1.0 + vec2(1.0, -1.0) * norm.xy);\n    if (uIsSphereMapAdditive) {\n      color += texture2D(uSphereMap, sphereCoord).rgb;\n    } else {\n      color *= texture2D(uSphereMap, sphereCoord).rgb;\n    }\n  }\n\n  // specular component\n  // vec3 halfAngle = normalize(uLightDirection/* + cameraDirection*/);\n  // float specularWeight = pow( max(0.001, dot(halfAngle, norm)) , uShininess );\n  // //float specularWeight = pow( max(0.0, dot(reflect(-uLightDirection, norm), cameraDirection)) , uShininess ); // another definition\n  // vec3 specular = specularWeight * uSpecularColor;\n\n  // vec2 toonCoord = vec2(0.0, 0.5 * (1.0 - dot( uLightDirection, norm )));\n\n  color *= uAmbientColor + uLightColor * (uDiffuseColor/* + specular*/);\n  color = clamp(color, 0.0, 1.0);\n\n  gl_FragColor = vec4(color, alpha);\n}\n';

MMD.ShadowMap = (function() {
  function ShadowMap(mmd) {
    this.mmd = mmd;
    this.framebuffer = this.texture = null;
    this.width = this.height = 2048;
    this.viewBroadness = 0.6;
    this.debug = false;
    this.initFramebuffer();
  }

  ShadowMap.prototype.initFramebuffer = function() {
    var gl, renderbuffer;
    gl = this.mmd.gl;
    this.framebuffer = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
    this.texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, this.texture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
    gl.generateMipmap(gl.TEXTURE_2D);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.width, this.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
    renderbuffer = gl.createRenderbuffer();
    gl.bindRenderbuffer(gl.RENDERBUFFER, renderbuffer);
    gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, this.width, this.height);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture, 0);
    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, renderbuffer);
    gl.bindTexture(gl.TEXTURE_2D, null);
    gl.bindRenderbuffer(gl.RENDERBUFFER, null);
    return gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  };

  ShadowMap.prototype.computeMatrices = function() {
    var cameraPosition, center, cx, cy, lengthScale, lightDirection, size, viewMatrix;
    center = vec3.create(this.mmd.center);
    lightDirection = vec3.createNormalize(this.mmd.lightDirection);
    vec3.add(lightDirection, center);
    cameraPosition = vec3.create(this.mmd.cameraPosition);
    lengthScale = vec3.lengthBetween(cameraPosition, center);
    size = lengthScale * this.viewBroadness;
    viewMatrix = mat4.lookAt(lightDirection, center, [0, 1, 0]);
    this.mvMatrix = mat4.createMultiply(viewMatrix, this.mmd.modelMatrix);
    mat4.multiplyVec3(viewMatrix, center);
    cx = center[0];
    cy = center[1];
    this.pMatrix = mat4.ortho(cx - size, cx + size, cy - size, cy + size, -size, size);
  };

  ShadowMap.prototype.beforeRender = function() {
    var gl, program;
    gl = this.mmd.gl;
    program = this.mmd.program;
    gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
    gl.viewport(0, 0, this.width, this.height);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    gl.uniform1i(program.uGenerateShadowMap, true);
    gl.uniformMatrix4fv(program.uMVMatrix, false, this.mvMatrix);
    gl.uniformMatrix4fv(program.uPMatrix, false, this.pMatrix);
  };

  ShadowMap.prototype.afterRender = function() {
    var gl, program;
    gl = this.mmd.gl;
    program = this.mmd.program;
    gl.uniform1i(program.uGenerateShadowMap, false);
    gl.bindTexture(gl.TEXTURE_2D, this.texture);
    gl.generateMipmap(gl.TEXTURE_2D);
    gl.bindTexture(gl.TEXTURE_2D, null);
    if (this.debug) {
      this.debugTexture();
    }
  };

  ShadowMap.prototype.getLightMatrix = function() {
    var lightMatrix;
    lightMatrix = mat4.createMultiply(this.pMatrix, this.mvMatrix);
    mat4.applyScale(lightMatrix, [0.5, 0.5, 0.5]);
    mat4.applyTranslate(lightMatrix, [0.5, 0.5, 0.5]);
    return lightMatrix;
  };

  ShadowMap.prototype.debugTexture = function() {
    var canvas, ctx, data, gl, i, imageData, pixelarray, _i, _ref;
    gl = this.mmd.gl;
    pixelarray = new Uint8Array(this.width * this.height * 4);
    gl.readPixels(0, 0, this.width, this.height, gl.RGBA, gl.UNSIGNED_BYTE, pixelarray);
    canvas = document.getElementById('shadowmap');
    if (!canvas) {
      canvas = document.createElement('canvas');
      canvas.id = 'shadowmap';
      canvas.width = this.width;
      canvas.height = this.height;
      canvas.style.border = 'solid black 1px';
      canvas.style.width = this.mmd.width + 'px';
      canvas.style.height = this.mmd.height + 'px';
      document.body.appendChild(canvas);
    }
    ctx = canvas.getContext('2d');
    imageData = ctx.getImageData(0, 0, this.width, this.height);
    data = imageData.data;
    for (i = _i = 0, _ref = data.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      data[i] = pixelarray[i];
    }
    return ctx.putImageData(imageData, 0, 0);
  };

  ShadowMap.prototype.getTexture = function() {
    return this.texture;
  };

  return ShadowMap;

})();

MMD.TextureManager = (function() {
  function TextureManager(mmd) {
    this.mmd = mmd;
    this.store = {};
    this.pendingCount = 0;
  }

  TextureManager.prototype.get = function(type, url) {
    var gl, texture;
    texture = this.store[url];
    if (texture) {
      return texture;
    }
    gl = this.mmd.gl;
    texture = this.store[url] = gl.createTexture();
    loadImage(url, (function(_this) {
      return function(img) {
        img = checkSize(img);
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
        if (type === 'toon') {
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        } else {
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
        }
        gl.generateMipmap(gl.TEXTURE_2D);
        gl.bindTexture(gl.TEXTURE_2D, null);
        if (_this.onload) {
          _this.onload(img);
        }
        return --_this.pendingCount;
      };
    })(this));
    this.pendingCount++;
    return texture;
  };

  return TextureManager;

})();

checkSize = function(img) {
  var canv, h, size, w;
  w = img.naturalWidth;
  h = img.naturalHeight;
  size = 1 << (Math.log(Math.min(w, h)) / Math.LN2 | 0);
  if (w !== h || w !== size) {
    canv = document.createElement('canvas');
    canv.height = canv.width = size;
    canv.getContext('2d').drawImage(img, 0, 0, w, h, 0, 0, size, size);
    img = canv;
  }
  return img;
};

loadImage = function(url, callback) {
  var img;
  img = new Image;
  img.onload = function() {
    return callback(img);
  };
  img.onerror = function() {
    return alert('failed to load image: ' + url);
  };
  img.src = url;
  return img;
};
